<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>helgoland-toolbox documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">helgoland-toolbox documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>HighlightDataset</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/helgoland/d3/src/lib/d3-timeseries-graph/d3-timeseries-graph.component.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#change">change</a>
                                </li>
                                <li>
                                        <a href="#id">id</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="change"></a>
                                        <span class="name"><b>change</b><a href="#change"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>change:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="id"></a>
                                        <span class="name"><b>id</b><a href="#id"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>id:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
    AfterViewInit,
    Component,
    ElementRef,
    EventEmitter,
    Input,
    IterableDiffers,
    Output,
    ViewChild,
    ViewEncapsulation,
} from &#x27;@angular/core&#x27;;
import {
    ColorService,
    Data,
    DatasetApiInterface,
    DatasetOptions,
    DatasetPresenterComponent,
    IDataset,
    InternalDatasetId,
    InternalIdHandler,
    MinMaxRange,
    SumValuesService,
    Time,
    Timeseries,
    TimeseriesData,
    Timespan,
    TimeValueTuple,
} from &#x27;@helgoland/core&#x27;;
import { LangChangeEvent, TranslateService } from &#x27;@ngx-translate/core&#x27;;
import * as d3 from &#x27;d3&#x27;;
import moment, { unitOfTime } from &#x27;moment&#x27;;

import { D3GraphHelperService } from &#x27;../helper/d3-graph-helper.service&#x27;;
import { D3TimeFormatLocaleService } from &#x27;../helper/d3-time-format-locale.service&#x27;;
import { DataConst, DataEntry, InternalDataEntry, YAxis, YAxisSettings } from &#x27;../model/d3-general&#x27;;
import { HighlightOutput } from &#x27;../model/d3-highlight&#x27;;
import { D3PlotOptions, HoveringStyle } from &#x27;../model/d3-plot-options&#x27;;
import { RangeCalculationsService } from &#x27;./../helper/range-calculations.service&#x27;;
import { D3GraphExtent, D3GraphObserver } from &#x27;./d3-timeseries-graph-control&#x27;;

interface HighlightDataset {
    id: string;
    change: boolean;
}

const TICKS_COUNT_YAXIS &#x3D; 5;

@Component({
    selector: &#x27;n52-d3-timeseries-graph&#x27;,
    templateUrl: &#x27;./d3-timeseries-graph.component.html&#x27;,
    styleUrls: [&#x27;./d3-timeseries-graph.component.scss&#x27;],
    encapsulation: ViewEncapsulation.None
})
export class D3TimeseriesGraphComponent
    extends DatasetPresenterComponent&lt;DatasetOptions, D3PlotOptions&gt;
    implements AfterViewInit {

    @Input()
    // difference to timespan/timeInterval --&gt; if brush, then this is the timespan of the main-diagram
    public mainTimeInterval: Timespan;

    @Output()
    public onHighlightChanged: EventEmitter&lt;HighlightOutput&gt; &#x3D; new EventEmitter();

    @Output()
    public onClickDataPoint: EventEmitter&lt;TimeseriesData[]&gt; &#x3D; new EventEmitter();

    @ViewChild(&#x27;d3timeseries&#x27;, { static: true })
    public d3Elem: ElementRef;

    public highlightOutput: HighlightOutput;

    // DOM elements
    protected rawSvg: d3.Selection&lt;SVGSVGElement, any, any, any&gt;;
    protected graph: d3.Selection&lt;SVGSVGElement, any, any, any&gt;;
    protected graphFocus: any;
    protected graphBody: any;
    private background: d3.Selection&lt;SVGSVGElement, any, any, any&gt;;

    private focusG: any;
    private highlightFocus: any;
    private highlightRect: any;
    private highlightText: any;
    private focuslabelTime: any;

    // options for interaction
    private mousedownBrush: boolean;

    // data types
    protected preparedData: InternalDataEntry[] &#x3D; [];
    protected preparedAxes: Map&lt;string, YAxisSettings&gt; &#x3D; new Map();
    protected datasetMap: Map&lt;string, DataConst&gt; &#x3D; new Map();
    protected listOfUoms: string[] &#x3D; [];
    /** calculated y axes for the diagram */
    private yAxes: YAxis[] &#x3D; [];
    private listOfSeparation &#x3D; Array();

    private xScaleBase: d3.ScaleTime&lt;number, number&gt;; // calculate diagram coord of x value
    private yScaleBase: d3.ScaleLinear&lt;number, number&gt;; // calculate diagram coord of y value
    // private dotsObjects: any[];
    private labelTimestamp: number[];
    private labelXCoord: number[];
    private distLabelXCoord: number[];
    private leftOffset: number;

    private height: number;
    private width: number;
    private margin &#x3D; {
        top: 10,
        right: 10,
        bottom: 40,
        left: 40
    };
    private maxLabelwidth &#x3D; 0;
    private addLineWidth &#x3D; 2; // value added to linewidth
    private loadingCounter &#x3D; 0;
    private loadingData: Set&lt;string&gt; &#x3D; new Set();
    private currentTimeId: string;

    private observer: Set&lt;D3GraphObserver&gt; &#x3D; new Set();

    // default plot options
    public plotOptions: D3PlotOptions &#x3D; {
        showReferenceValues: false,
        generalizeAllways: true,
        togglePanZoom: true,
        hoverable: true,
        hoverStyle: HoveringStyle.point,
        grid: true,
        yaxis: true,
        overview: false,
        showTimeLabel: true,
        requestBeforeAfterValues: false
    };

    private lastHoverPositioning: number;

    constructor(
        protected iterableDiffers: IterableDiffers,
        protected api: DatasetApiInterface,
        protected datasetIdResolver: InternalIdHandler,
        protected timeSrvc: Time,
        protected timeFormatLocaleService: D3TimeFormatLocaleService,
        protected colorService: ColorService,
        protected translateService: TranslateService,
        protected sumValues: SumValuesService,
        protected rangeCalc: RangeCalculationsService,
        protected graphHelper: D3GraphHelperService
    ) {
        super(iterableDiffers, api, datasetIdResolver, timeSrvc, translateService);
    }

    public ngAfterViewInit(): void {
        this.currentTimeId &#x3D; this.uuidv4();

        this.rawSvg &#x3D; d3.select&lt;SVGSVGElement, any&gt;(this.d3Elem.nativeElement)
            .append&lt;SVGSVGElement&gt;(&#x27;svg&#x27;)
            .attr(&#x27;width&#x27;, &#x27;100%&#x27;)
            .attr(&#x27;height&#x27;, &#x27;100%&#x27;);

        this.graph &#x3D; this.rawSvg
            .append&lt;SVGSVGElement&gt;(&#x27;g&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + (this.margin.left + this.maxLabelwidth) + &#x27;,&#x27; + this.margin.top + &#x27;)&#x27;);

        this.graphFocus &#x3D; this.rawSvg
            .append(&#x27;g&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + (this.margin.left + this.maxLabelwidth) + &#x27;,&#x27; + this.margin.top + &#x27;)&#x27;);

        this.mousedownBrush &#x3D; false;
        this.redrawCompleteGraph();
    }

    public registerObserver(obs: D3GraphObserver) {
        this.observer.add(obs);
    }

    public unregisterObserver(obs: D3GraphObserver) {
        this.observer.delete(obs);
    }

    public getGraphElem() {
        return this.graph;
    }

    protected onLanguageChanged(langChangeEvent: LangChangeEvent): void {
        this.redrawCompleteGraph();
    }

    public reloadDataForDatasets(datasetIds: string[]): void {
        datasetIds.forEach(id &#x3D;&gt; {
            if (this.datasetMap.has(id)) {
                this.loadDatasetData(this.datasetMap.get(id), true);
            }
        });
    }

    protected addDataset(id: string, url: string): void {
        this.api.getSingleTimeseries(id, url).subscribe(
            (timeseries) &#x3D;&gt; this.loadAddedDataset(timeseries),
            (error) &#x3D;&gt; {
                this.api.getDataset(id, url).subscribe(
                    (dataset) &#x3D;&gt; this.loadAddedDataset(dataset),
                );
            }
        );
    }

    protected removeDataset(internalId: string): void {
        this.datasetMap.delete(internalId);
        this.preparedAxes.delete(internalId);
        let spliceIdx &#x3D; this.preparedData.findIndex((entry) &#x3D;&gt; entry.internalId &#x3D;&#x3D;&#x3D; internalId);
        if (spliceIdx &gt;&#x3D; 0) {
            this.preparedData.splice(spliceIdx, 1);
            if (this.preparedData.length &lt;&#x3D; 0) {
            } else {
                this.preparedData.forEach((entry) &#x3D;&gt; {
                    this.processData(entry);
                });
            }
            this.redrawCompleteGraph();
        }
    }

    protected setSelectedId(internalId: string): void {
        const internalEntry &#x3D; this.preparedData.find((e) &#x3D;&gt; e.internalId &#x3D;&#x3D;&#x3D; internalId);
        if (internalEntry) { internalEntry.selected &#x3D; true; }
        this.redrawCompleteGraph();
    }

    protected removeSelectedId(internalId: string): void {
        const internalEntry &#x3D; this.preparedData.find((e) &#x3D;&gt; e.internalId &#x3D;&#x3D;&#x3D; internalId);
        if (internalEntry) { internalEntry.selected &#x3D; false; }
        this.redrawCompleteGraph();
    }

    protected presenterOptionsChanged(options: D3PlotOptions): void {
        if (this.plotOptions.hoverStyle !&#x3D;&#x3D; HoveringStyle.point &amp;&amp; options.hoverStyle &#x3D;&#x3D;&#x3D; HoveringStyle.point) {
            d3.select(&#x27;g.d3line&#x27;).attr(&#x27;visibility&#x27;, &#x27;visible&#x27;);
        }
        Object.assign(this.plotOptions, options);
        this.redrawCompleteGraph();
    }

    protected datasetOptionsChanged(internalId: string, options: DatasetOptions, firstChange: boolean): void {
        if (!firstChange &amp;&amp; this.datasetMap.has(internalId)) {
            this.loadDatasetData(this.datasetMap.get(internalId), false);
        }
    }

    protected timeIntervalChanges(): void {
        this.datasetMap.forEach((dataset) &#x3D;&gt; {
            this.loadDatasetData(dataset, false);
        });
    }

    protected onResize(): void {
        this.redrawCompleteGraph();
    }

    public centerTime(timestamp: number): void {
        const centeredTimespan &#x3D; this.timeSrvc.centerTimespan(this.timespan, new Date(timestamp));
        this.onTimespanChanged.emit(centeredTimespan);
    }

    public changeTime(from: number, to: number): void {
        this.onTimespanChanged.emit(new Timespan(from, to));
    }

    private loadAddedDataset(dataset: IDataset): void {
        this.datasetMap.set(dataset.internalId, dataset);
        this.loadDatasetData(dataset, false);
    }

    // load data of dataset
    private loadDatasetData(dataset: IDataset, force: boolean): void {
        const datasetOptions &#x3D; this.datasetOptions.get(dataset.internalId);
        if (this.loadingCounter &#x3D;&#x3D;&#x3D; 0) { this.onContentLoading.emit(true); }
        this.loadingCounter++;

        if (dataset instanceof Timeseries) {
            const buffer &#x3D; this.timeSrvc.getBufferedTimespan(this.timespan, 0.2);

            this.loadingData.add(dataset.internalId);
            this.dataLoaded.emit(this.loadingData);
            this.api.getTsData&lt;[number, number]&gt;(dataset.id, dataset.url, buffer,
                {
                    format: &#x27;flot&#x27;,
                    expanded: this.plotOptions.showReferenceValues || this.plotOptions.requestBeforeAfterValues,
                    generalize: this.plotOptions.generalizeAllways || datasetOptions.generalize
                },
                { forceUpdate: force }
            ).subscribe(
                (result) &#x3D;&gt; this.prepareData(dataset, result),
                (error) &#x3D;&gt; this.onError(error),
                () &#x3D;&gt; this.onCompleteLoadingData(dataset)
            );
        }
    }

    private onCompleteLoadingData(dataset: IDataset): void {
        this.loadingData.delete(dataset.internalId);
        this.dataLoaded.emit(this.loadingData);
        this.loadingCounter--;
        if (this.loadingCounter &#x3D;&#x3D;&#x3D; 0) { this.onContentLoading.emit(false); }
    }

    /**
     * Function to prepare each dataset for the graph and adding it to an array of datasets.
     * @param dataset {IDataset} Object of the whole dataset
     */
    private prepareData(dataset: IDataset, data: Data&lt;TimeValueTuple&gt;): void {

        // add surrounding entries to the set
        if (data.valueBeforeTimespan) { data.values.unshift(data.valueBeforeTimespan); }
        if (data.valueAfterTimespan) { data.values.push(data.valueAfterTimespan); }

        this.datasetMap.get(dataset.internalId).data &#x3D; data;
        const datasetIdx &#x3D; this.preparedData.findIndex((e) &#x3D;&gt; e.internalId &#x3D;&#x3D;&#x3D; dataset.internalId);
        const options &#x3D; this.datasetOptions.get(dataset.internalId);

        let barConfig: { startOf: unitOfTime.StartOf; period: moment.Duration; };

        // sum values for bar chart visualization
        if (options.type &#x3D;&#x3D;&#x3D; &#x27;bar&#x27;) {
            barConfig &#x3D; {
                startOf: options.barStartOf as unitOfTime.StartOf,
                period: moment.duration(options.barPeriod)
            };
            if (barConfig.period.asMilliseconds() &#x3D;&#x3D;&#x3D; 0) {
                throw new Error(&#x60;${dataset.internalId} needs a valid barPeriod&#x60;);
            }
            data.values &#x3D; this.sumValues.sum(barConfig.startOf, barConfig.period, data.values);
        }

        // generate random color, if color is not defined
        if (options.color &#x3D;&#x3D;&#x3D; undefined) {
            options.color &#x3D; this.colorService.getColor();
        }

        // end of check for datasets
        const dataEntry: InternalDataEntry &#x3D; {
            internalId: dataset.internalId,
            id: (datasetIdx &gt;&#x3D; 0 ? datasetIdx : this.preparedData.length),
            options,
            selected: this.selectedDatasetIds.indexOf(dataset.internalId) &gt;&#x3D; 0,
            data: options.visible ? data.values.map(d &#x3D;&gt; ({ timestamp: d[0], value: d[1] })) : [],
            axisOptions: {
                uom: dataset.uom,
                label: dataset.label,
                zeroBased: options.zeroBasedYAxis,
                yAxisRange: options.yAxisRange,
                autoRangeSelection: options.autoRangeSelection,
                separateYAxis: options.separateYAxis,
                parameters: {
                    feature: dataset.parameters.feature,
                    phenomenon: dataset.parameters.phenomenon,
                    offering: dataset.parameters.offering
                }
            },
            referenceValueData: [],
            visible: options.visible,
            bar: barConfig
        };

        let separationIdx: number &#x3D; this.listOfSeparation.findIndex((id) &#x3D;&gt; id &#x3D;&#x3D;&#x3D; dataset.internalId);
        if (options.separateYAxis) {
            if (separationIdx &lt; 0) {
                this.listOfSeparation.push(dataset.internalId);
            }
        } else {
            this.listOfSeparation &#x3D; this.listOfSeparation.filter(entry &#x3D;&gt; entry !&#x3D;&#x3D; dataset.internalId);
        }

        if (datasetIdx &gt;&#x3D; 0) {
            this.preparedData[datasetIdx] &#x3D; dataEntry;
        } else {
            this.preparedData.push(dataEntry);
        }
        this.addReferenceValueData(dataEntry, options, data, dataset.uom);
        this.processData(dataEntry);
        this.redrawCompleteGraph();
    }

    /**
     * Function to add referencevaluedata to the dataset (e.g. mean).
     * @param internalId {String} String with the id of a dataset
     * @param styles {DatasetOptions} Object containing information for dataset styling
     * @param data {Data} Array of Arrays containing the measurement-data of the dataset
     * @param uom {String} String with the uom of a dataset
     */
    private addReferenceValueData(dataEntry: InternalDataEntry, styles: DatasetOptions, data: Data&lt;TimeValueTuple&gt;, uom: string): void {
        if (this.plotOptions.showReferenceValues) {
            dataEntry.referenceValueData &#x3D; styles.showReferenceValues.map((refValue) &#x3D;&gt; ({
                id: refValue.id,
                color: refValue.color,
                data: data.referenceValues[refValue.id].map(d &#x3D;&gt; ({ timestamp: d[0], value: d[1] }))
            }));
        }
    }

    /**
     * Function that processes the data to calculate y axis range of each dataset.
     * @param entry {DataEntry} Object containing dataset related data.
     */
    protected processData(entry: InternalDataEntry): void {
        if (entry.visible) {
            let visualRange: MinMaxRange;
            let rangeFixed &#x3D; false;
            // set out of yAxisRange
            if (entry.axisOptions.yAxisRange &amp;&amp; entry.axisOptions.yAxisRange.min !&#x3D;&#x3D; entry.axisOptions.yAxisRange.max) {
                visualRange &#x3D; entry.axisOptions.yAxisRange;
                if (visualRange.min &gt; visualRange.max) {
                    const max &#x3D; visualRange.min;
                    visualRange.min &#x3D; visualRange.max;
                    visualRange.min &#x3D; max;
                }
                rangeFixed &#x3D; true;
            } else {
                // calculate default range
                const baseDataExtent &#x3D; d3.extent&lt;DataEntry, number&gt;(entry.data, (d) &#x3D;&gt; {
                    if (typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
                        // with timespan restriction, it only selects values inside the selected timespan
                        // if (this.timespan.from &lt;&#x3D; d.timestamp &amp;&amp; this.timespan.to &gt;&#x3D; d.timestamp) { return d.value; }
                        return d.value;
                    } else {
                        return null;
                    }
                });

                const dataExtentRafValues &#x3D; entry.referenceValueData.map(e &#x3D;&gt; {
                    return d3.extent&lt;DataEntry, number&gt;(e.data, (d) &#x3D;&gt; (typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) ? d.value : null);
                });

                const rangeMin &#x3D; d3.min([baseDataExtent[0], ...dataExtentRafValues.map(e &#x3D;&gt; e[0])]);
                const rangeMax &#x3D; d3.max([baseDataExtent[1], ...dataExtentRafValues.map(e &#x3D;&gt; e[1])]);
                const dataExtent &#x3D; [rangeMin, rangeMax];

                visualRange &#x3D; {
                    min: dataExtent[0],
                    max: dataExtent[1]
                };
            }

            // set out of zeroBasedAxis
            if (entry.axisOptions.zeroBased) {
                if (visualRange.min &gt; 0) {
                    visualRange.min &#x3D; 0;
                }
                if (visualRange.max &lt; 0) {
                    visualRange.max &#x3D; 0;
                }
            }

            this.preparedAxes.set(entry.internalId, {
                rangeFixed,
                visualRange,
                entry
            });
        }
    }

    /**
     * Function that returns the height of the graph diagram.
     */
    private calculateHeight(): number {
        return (this.d3Elem.nativeElement as HTMLElement).clientHeight - this.margin.top - this.margin.bottom + (this.plotOptions.showTimeLabel ? 0 : 20);
    }

    /**
     * Function that returns the width of the graph diagram.
     */
    private calculateWidth(): number {
        return this.rawSvg.node().width.baseVal.value - this.margin.left - this.margin.right - this.maxLabelwidth;
    }

    /**
     * Just sets the timespan, which is used for the diagram visualisation
     */
    public setTimespan(timespan: Timespan) {
        this.timespan &#x3D; timespan;
    }

    public drawBaseGraph(): void {
        this.drawYGridLines();
        this.drawXaxis(this.leftOffset);
        this.drawAllCharts();
    }

    private drawYGridLines() {
        this.graph.selectAll(&#x27;.grid.y-grid&#x27;).remove();
        if (this.yAxes.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; this.plotOptions.grid) {
            this.graph.append(&#x27;svg:g&#x27;)
                .attr(&#x27;class&#x27;, &#x27;grid y-grid&#x27;)
                .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + this.leftOffset + &#x27;, 0)&#x27;)
                .call(d3.axisLeft(this.yAxes[0].yScale)
                    .ticks(TICKS_COUNT_YAXIS)
                    .tickSize(-this.width + this.leftOffset)
                    .tickFormat(() &#x3D;&gt; &#x27;&#x27;));
        }
    }

    /**
     * Function to plot the whole graph and its dependencies
     * (graph line, graph axes, event handlers)
     */
    public redrawCompleteGraph(): void {
        if (!this.graph || !this.rawSvg || !this.datasetIds) { return; }
        this.highlightOutput &#x3D; {
            timestamp: 0,
            ids: new Map()
        };

        this.preparedData.forEach((entry) &#x3D;&gt; {
            let idx: number &#x3D; this.listOfUoms.findIndex((uom) &#x3D;&gt; uom &#x3D;&#x3D;&#x3D; entry.axisOptions.uom);
            if (idx &lt; 0) { this.listOfUoms.push(entry.axisOptions.uom); }
        });

        this.height &#x3D; this.calculateHeight();
        this.width &#x3D; this.calculateWidth() - 20; // add buffer to the left to garantee visualization of last date (tick x-axis)
        this.graph.selectAll(&#x27;*&#x27;).remove();
        this.graphFocus.selectAll(&#x27;*&#x27;).remove();

        this.leftOffset &#x3D; 0;
        this.yScaleBase &#x3D; null;

        // reset y axes
        this.yAxes &#x3D; [];
        this.prepareYAxes();

        this.yAxes.forEach(axis &#x3D;&gt; {
            // debugger;
            axis.first &#x3D; (this.yScaleBase &#x3D;&#x3D;&#x3D; null);
            axis.offset &#x3D; this.leftOffset;

            let yAxisResult &#x3D; this.drawYaxis(axis);
            if (this.yScaleBase &#x3D;&#x3D;&#x3D; null) {
                this.yScaleBase &#x3D; yAxisResult.yScale;
                this.leftOffset &#x3D; yAxisResult.buffer;
            } else {
                this.leftOffset &#x3D; yAxisResult.buffer;
            }
            axis.yScale &#x3D; yAxisResult.yScale;
        });

        if (!this.yScaleBase) { return; }

        // create background as rectangle providing panning
        this.background &#x3D; this.graph.append&lt;SVGSVGElement&gt;(&#x27;svg:rect&#x27;)
            .attr(&#x27;width&#x27;, this.width - this.leftOffset)
            .attr(&#x27;height&#x27;, this.height)
            .attr(&#x27;id&#x27;, &#x27;backgroundRect&#x27;)
            .attr(&#x27;fill&#x27;, &#x27;none&#x27;)
            .attr(&#x27;stroke&#x27;, &#x27;none&#x27;)
            .attr(&#x27;pointer-events&#x27;, &#x27;all&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + this.leftOffset + &#x27;, 0)&#x27;);

        this.drawBaseGraph();

        this.addTimespanJumpButtons();

        // create background rect
        if (!this.plotOptions.overview) {
            // execute when it is not an overview diagram
            // mouse events hovering
            if (this.plotOptions.hoverable) {
                if (this.plotOptions.hoverStyle &#x3D;&#x3D;&#x3D; HoveringStyle.line) {
                    this.createLineHovering();
                } else {
                    d3.select(&#x27;g.d3line&#x27;).attr(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
                }
            }

            this.observer.forEach(e &#x3D;&gt; {
                if (e.adjustBackground) {
                    const graphExtent: D3GraphExtent &#x3D; {
                        width: this.width,
                        height: this.height,
                        leftOffset: this.leftOffset,
                        margin: this.margin
                    };
                    e.adjustBackground(this.background, graphExtent, this.preparedData, this.graph, this.timespan);
                }
            });
        } else {
            // execute when it is overview diagram
            let interval: [number, number] &#x3D; this.getXDomainByTimestamp();
            let overviewTimespanInterval &#x3D; [interval[0], interval[1]];

            // create brush
            let brush &#x3D; d3.brushX()
                .extent([[0, 0], [this.width, this.height]])
                .on(&#x27;end&#x27;, () &#x3D;&gt; {
                    // on mouseclick change time after brush was moved
                    if (this.mousedownBrush) {
                        let timeByCoord: [number, number] &#x3D; this.getTimestampByCoord(d3.event.selection[0], d3.event.selection[1]);
                        this.changeTime(timeByCoord[0], timeByCoord[1]);
                    }
                    this.mousedownBrush &#x3D; false;
                });

            // add brush to svg
            this.background &#x3D; this.graph.append&lt;SVGSVGElement&gt;(&#x27;g&#x27;)
                .attr(&#x27;width&#x27;, this.width)
                .attr(&#x27;height&#x27;, this.height)
                .attr(&#x27;pointer-events&#x27;, &#x27;all&#x27;)
                .attr(&#x27;class&#x27;, &#x27;brush&#x27;)
                .call(brush)
                .call(brush.move, overviewTimespanInterval);

            /**
             * add event to selection to prevent unnecessary re-rendering of brush
             * add style of brush selection here
             * e.g. &#x27;fill&#x27; for color,
             * &#x27;stroke&#x27; for borderline-color,
             * &#x27;stroke-dasharray&#x27; for customizing borderline-style
             */
            this.background.selectAll(&#x27;.selection&#x27;)
                .attr(&#x27;stroke&#x27;, &#x27;none&#x27;)
                .on(&#x27;mousedown&#x27;, () &#x3D;&gt; {
                    this.mousedownBrush &#x3D; true;
                });

            // do not allow clear selection
            this.background.selectAll(&#x27;.overlay&#x27;)
                .remove();

            // add event to resizing handle to allow change time on resize
            this.background.selectAll(&#x27;.handle&#x27;)
                .style(&#x27;fill&#x27;, &#x27;red&#x27;)
                .style(&#x27;opacity&#x27;, 0.3)
                .attr(&#x27;stroke&#x27;, &#x27;none&#x27;)
                .on(&#x27;mousedown&#x27;, () &#x3D;&gt; {
                    this.mousedownBrush &#x3D; true;
                });
        }
        this.drawBackground();
    }

    protected prepareYAxes() {
        this.datasetIds.forEach(key &#x3D;&gt; this.createYAxisForId(key));
    }

    protected createYAxisForId(key: string) {
        if (this.preparedAxes.has(key) &amp;&amp; this.datasetMap.get(key)) {
            // only create axis for datsets with datapoints inside selected timespan
            if (this.datasetMap.get(key).data.values.findIndex(el &#x3D;&gt; el[0] &gt;&#x3D; this.timespan.from &amp;&amp; el[0] &lt;&#x3D; this.timespan.to) &gt;&#x3D; 0) {
                const axisSettings &#x3D; this.preparedAxes.get(key);
                if (axisSettings.entry.options.separateYAxis) {
                    // create sepearte axis
                    this.yAxes.push({
                        uom: axisSettings.entry.axisOptions.uom,
                        range: axisSettings.visualRange,
                        rangeFixed: axisSettings.rangeFixed,
                        selected: axisSettings.entry.selected,
                        seperate: true,
                        ids: [key],
                        label: axisSettings.entry.axisOptions.parameters.feature.label
                    });
                } else {
                    // find matching axis or add new
                    const axis &#x3D; this.yAxes.find(e &#x3D;&gt; e.uom.includes(axisSettings.entry.axisOptions.uom) &amp;&amp; !e.seperate);
                    if (axis) {
                        // add id to axis
                        axis.ids.push(key);
                        // update range for axis
                        if (axisSettings.rangeFixed &amp;&amp; axis.rangeFixed) {
                            axis.range &#x3D; this.rangeCalc.mergeRanges(axis.range, axisSettings.visualRange);
                        } else if (axisSettings.rangeFixed) {
                            axis.range &#x3D; axisSettings.visualRange;
                            axis.rangeFixed &#x3D; true;
                        } else if (!axisSettings.rangeFixed &amp;&amp; !axis.rangeFixed) {
                            axis.range &#x3D; this.rangeCalc.mergeRanges(axis.range, axisSettings.visualRange);
                        }
                        // update selection
                        if (axis.selected) {
                            axis.selected &#x3D; axisSettings.entry.selected;
                        }
                    } else {
                        this.yAxes.push({
                            uom: axisSettings.entry.axisOptions.uom,
                            range: axisSettings.visualRange,
                            seperate: false,
                            selected: axisSettings.entry.selected,
                            rangeFixed: axisSettings.rangeFixed,
                            ids: [key]
                        });
                    }
                }
            }
        }
    }

    private createLineHovering() {
        this.background
            .on(&#x27;mousemove.focus&#x27;, this.mousemoveHandler)
            .on(&#x27;mouseout.focus&#x27;, this.mouseoutHandler);
        // line inside graph
        this.highlightFocus &#x3D; this.focusG.append(&#x27;svg:line&#x27;)
            .attr(&#x27;class&#x27;, &#x27;mouse-focus-line&#x27;)
            .attr(&#x27;x2&#x27;, &#x27;0&#x27;)
            .attr(&#x27;y2&#x27;, &#x27;0&#x27;)
            .attr(&#x27;x1&#x27;, &#x27;0&#x27;)
            .attr(&#x27;y1&#x27;, &#x27;0&#x27;)
            .style(&#x27;stroke&#x27;, &#x27;black&#x27;)
            .style(&#x27;stroke-width&#x27;, &#x27;1px&#x27;);
        this.preparedData.forEach((entry) &#x3D;&gt; {
            // label inside graph
            entry.focusLabelRect &#x3D; this.focusG.append(&#x27;svg:rect&#x27;)
                .attr(&#x27;class&#x27;, &#x27;mouse-focus-label&#x27;)
                .style(&#x27;fill&#x27;, &#x27;white&#x27;)
                .style(&#x27;stroke&#x27;, &#x27;none&#x27;)
                .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;);
            entry.focusLabel &#x3D; this.focusG.append(&#x27;svg:text&#x27;)
                .attr(&#x27;class&#x27;, &#x27;mouse-focus-label&#x27;)
                .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
                .style(&#x27;fill&#x27;, entry.options.color)
                .style(&#x27;font-weight&#x27;, &#x27;lighter&#x27;);
            this.focuslabelTime &#x3D; this.focusG.append(&#x27;svg:text&#x27;)
                .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
                .attr(&#x27;class&#x27;, &#x27;mouse-focus-time&#x27;);
        });
    }

    private clickDataPoint(d: DataEntry, entry: InternalDataEntry) {
        if (d !&#x3D;&#x3D; undefined) {
            const externalId: InternalDatasetId &#x3D; this.datasetIdResolver.resolveInternalId(entry.internalId);
            const apiurl &#x3D; externalId.url;
            const timespan: Timespan &#x3D; { from: d.timestamp, to: d.timestamp };

            // request all timeseries that have data for the same offering and feature
            this.api.getTimeseries(apiurl,
                {
                    offering: entry.axisOptions.parameters.offering.id,
                    feature: entry.axisOptions.parameters.feature.id
                }).subscribe(
                    (tsArray) &#x3D;&gt; {
                        const timeseries &#x3D; [];
                        tsArray.forEach(ts &#x3D;&gt; {
                            timeseries.push(ts.id);
                        });

                        // request ts data by timeseries ID for specific offering and feature
                        this.api.getTimeseriesData(apiurl, timeseries, timespan)
                            .subscribe(
                                (tsData) &#x3D;&gt; this.onClickDataPoint.emit(tsData),
                                (error) &#x3D;&gt; console.error(error)
                            );
                    },
                    (error) &#x3D;&gt; console.error(error)
                );
        }
    }

    private addTimespanJumpButtons(): void {
        let dataVisible &#x3D; false;
        let formerTimestamp &#x3D; null;
        let laterTimestamp &#x3D; null;
        if (this.plotOptions.requestBeforeAfterValues) {
            this.preparedData.forEach((entry: InternalDataEntry) &#x3D;&gt; {
                const firstIdxInTimespan &#x3D; entry.data.findIndex(e &#x3D;&gt; (this.timespan.from &lt; e.timestamp &amp;&amp; this.timespan.to &gt; e.timestamp) &amp;&amp; typeof e.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;);
                if (firstIdxInTimespan &lt; 0) {
                    const lastIdxInTimespan &#x3D; entry.data.findIndex(e &#x3D;&gt; (e.timestamp &gt; this.timespan.from &amp;&amp; e.timestamp &gt; this.timespan.to) &amp;&amp; typeof e.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;);
                    if (lastIdxInTimespan &gt;&#x3D; 0) {
                        laterTimestamp &#x3D; entry.data[entry.data.length - 1].timestamp;
                    }
                    const temp &#x3D; entry.data.findIndex(e &#x3D;&gt; (e.timestamp &lt; this.timespan.from &amp;&amp; e.timestamp &lt; this.timespan.to) &amp;&amp; typeof e.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;);
                    if (temp &gt;&#x3D; 0) {
                        formerTimestamp &#x3D; entry.data[entry.data.length - 1].timestamp;
                    }
                } else {
                    dataVisible &#x3D; true;
                }
            });
        }
        if (!dataVisible) {
            const buttonWidth &#x3D; 50;
            const leftRight &#x3D; 15;
            if (formerTimestamp) {
                const g &#x3D; this.background.append(&#x27;g&#x27;);
                g.append(&#x27;svg:rect&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;formerButton&#x27;)
                    .attr(&#x27;width&#x27;, buttonWidth + &#x27;px&#x27;)
                    .attr(&#x27;height&#x27;, this.height + &#x27;px&#x27;)
                    .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + this.leftOffset + &#x27;, 0)&#x27;)
                    .on(&#x27;click&#x27;, () &#x3D;&gt; this.centerTime(formerTimestamp));
                g.append(&#x27;line&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;arrow&#x27;)
                    .attr(&#x27;x1&#x27;, 0 + this.leftOffset + leftRight + &#x27;px&#x27;)
                    .attr(&#x27;y1&#x27;, this.height / 2 + &#x27;px&#x27;)
                    .attr(&#x27;x2&#x27;, 0 + this.leftOffset + (buttonWidth - leftRight) + &#x27;px&#x27;)
                    .attr(&#x27;y2&#x27;, this.height / 2 - (buttonWidth - leftRight) / 2 + &#x27;px&#x27;);
                g.append(&#x27;line&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;arrow&#x27;)
                    .attr(&#x27;x1&#x27;, 0 + this.leftOffset + leftRight + &#x27;px&#x27;)
                    .attr(&#x27;y1&#x27;, this.height / 2 + &#x27;px&#x27;)
                    .attr(&#x27;x2&#x27;, 0 + this.leftOffset + (buttonWidth - leftRight) + &#x27;px&#x27;)
                    .attr(&#x27;y2&#x27;, this.height / 2 + (buttonWidth - leftRight) / 2 + &#x27;px&#x27;);
            }
            if (laterTimestamp) {
                const g &#x3D; this.background.append(&#x27;g&#x27;);
                g.append(&#x27;svg:rect&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;laterButton&#x27;)
                    .attr(&#x27;width&#x27;, &#x27;50px&#x27;)
                    .attr(&#x27;height&#x27;, this.height)
                    .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + (this.width - 50) + &#x27;, 0)&#x27;)
                    .on(&#x27;click&#x27;, () &#x3D;&gt; this.centerTime(laterTimestamp));
                g.append(&#x27;line&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;arrow&#x27;)
                    .attr(&#x27;x1&#x27;, this.width - leftRight + &#x27;px&#x27;)
                    .attr(&#x27;y1&#x27;, this.height / 2 + &#x27;px&#x27;)
                    .attr(&#x27;x2&#x27;, this.width - (buttonWidth - leftRight) + &#x27;px&#x27;)
                    .attr(&#x27;y2&#x27;, this.height / 2 - (buttonWidth - leftRight) / 2 + &#x27;px&#x27;);
                g.append(&#x27;line&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;arrow&#x27;)
                    .attr(&#x27;x1&#x27;, this.width - leftRight + &#x27;px&#x27;)
                    .attr(&#x27;y1&#x27;, this.height / 2 + &#x27;px&#x27;)
                    .attr(&#x27;x2&#x27;, this.width - (buttonWidth - leftRight) + &#x27;px&#x27;)
                    .attr(&#x27;y2&#x27;, this.height / 2 + (buttonWidth - leftRight) / 2 + &#x27;px&#x27;);
            }
        }
    }

    /**
     * Draws for every preprared data entry the chart.
     */
    protected drawAllCharts(): void {
        this.graph.selectAll(&#x27;.diagram-path&#x27;).remove();
        this.focusG &#x3D; this.graphFocus.append(&#x27;g&#x27;);
        if ((this.plotOptions.hoverStyle &#x3D;&#x3D;&#x3D; HoveringStyle.point) &amp;&amp; !this.plotOptions.overview) {
            // create label for point hovering
            this.highlightRect &#x3D; this.focusG.append(&#x27;svg:rect&#x27;);
            this.highlightText &#x3D; this.focusG.append(&#x27;svg:text&#x27;);
        }
        this.preparedData.forEach((entry) &#x3D;&gt; {
            this.drawChart(entry);
        });
    }

    /**
     * Function that calculates and returns the x diagram coordinate for the brush range
     * for the overview diagram by the selected time interval of the main diagram.
     * Calculate to get brush extent when main diagram time interval changes.
     */
    private getXDomainByTimestamp(): [number, number] {
        /**
         * calculate range of brush with timestamp and not diagram coordinates
         * formula:
         * brush_min &#x3D;
         * (overview_width / (overview_max - overview_min)) * (brush_min - overview_min)
         * brus_max &#x3D;
         * (overview_width / (overview_max - overview_min)) * (brush_max - overview_min)
         */

        let minOverviewTimeInterval &#x3D; this.timespan.from;
        let maxOverviewTimeInterval &#x3D; this.timespan.to;
        let minDiagramTimestamp &#x3D; this.mainTimeInterval.from;
        let maxDiagramTimestamp &#x3D; this.mainTimeInterval.to;
        let diagramWidth &#x3D; this.width;

        let diffOverviewTimeInterval &#x3D; maxOverviewTimeInterval - minOverviewTimeInterval;
        let divOverviewTimeWidth &#x3D; diagramWidth / diffOverviewTimeInterval;
        let minCalcBrush: number &#x3D; divOverviewTimeWidth * (minDiagramTimestamp - minOverviewTimeInterval);
        let maxCalcBrush: number &#x3D; divOverviewTimeWidth * (maxDiagramTimestamp - minOverviewTimeInterval);

        return [minCalcBrush, maxCalcBrush];
    }

    /**
     * Function that calculates and returns the timestamp for the main diagram calculated
     * by the selected coordinate of the brush range.
     * @param minCalcBrush {Number} Number with the minimum coordinate of the selected brush range.
     * @param maxCalcBrush {Number} Number with the maximum coordinate of the selected brush range.
     */
    private getTimestampByCoord(minCalcBrush: number, maxCalcBrush: number): [number, number] {
        /**
         * calculate range of brush with timestamp and not diagram coordinates
         * formula:
         * minDiagramTimestamp &#x3D;
         * ((minCalcBrush / overview_width) * (overview_max - overview_min)) + overview_min
         * maxDiagramTimestamp &#x3D;
         * ((maxCalcBrush / overview_width) * (overview_max - overview_min)) + overview_min
         */

        let minOverviewTimeInterval &#x3D; this.timespan.from;
        let maxOverviewTimeInterval &#x3D; this.timespan.to;
        let diagramWidth &#x3D; this.width;

        let diffOverviewTimeInterval &#x3D; maxOverviewTimeInterval - minOverviewTimeInterval;
        let minDiagramTimestamp: number &#x3D; ((minCalcBrush / diagramWidth) * diffOverviewTimeInterval) + minOverviewTimeInterval;
        let maxDiagramTimestamp: number &#x3D; ((maxCalcBrush / diagramWidth) * diffOverviewTimeInterval) + minOverviewTimeInterval;

        return [minDiagramTimestamp, maxDiagramTimestamp];
    }

    /**
     * Function that draws the x axis to the svg element.
     * @param bufferXrange {Number} Number with the distance between left edge and the beginning of the graph.
     */
    private drawXaxis(bufferXrange: number): void {
        // range for x axis scale
        this.xScaleBase &#x3D; d3.scaleTime()
            .domain([new Date(this.timespan.from), new Date(this.timespan.to)])
            .range([bufferXrange, this.width]); // .nice(); // function which makes the &quot;beautiful&quot; (not used here, because the ticks are inconsistent with this function)

        let xAxis &#x3D; d3.axisBottom(this.xScaleBase)
            .tickFormat(d &#x3D;&gt; {
                const date &#x3D; new Date(d.valueOf());

                const formatMillisecond &#x3D; &#x27;.%L&#x27;,
                    formatSecond &#x3D; &#x27;:%S&#x27;,
                    formatMinute &#x3D; &#x27;%H:%M&#x27;,
                    formatHour &#x3D; &#x27;%H:%M&#x27;,
                    formatDay &#x3D; &#x27;%b %d&#x27;,
                    formatWeek &#x3D; &#x27;%b %d&#x27;,
                    formatMonth &#x3D; &#x27;%B&#x27;,
                    formatYear &#x3D; &#x27;%Y&#x27;;

                const format &#x3D; d3.timeSecond(date) &lt; date ? formatMillisecond
                    : d3.timeMinute(date) &lt; date ? formatSecond
                        : d3.timeHour(date) &lt; date ? formatMinute
                            : d3.timeDay(date) &lt; date ? formatHour
                                : d3.timeMonth(date) &lt; date ? (d3.timeWeek(date) &lt; date ? formatDay : formatWeek)
                                    : d3.timeYear(date) &lt; date ? formatMonth
                                        : formatYear;
                return this.timeFormatLocaleService.getTimeLocale(format)(new Date(d.valueOf()));
            });

        // update x axis
        this.graph.selectAll(&#x27;.x.axis.bottom&#x27;).remove();
        this.graph.append(&#x27;g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;x axis bottom&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(0,&#x27; + this.height + &#x27;)&#x27;)
            .call(xAxis)
            .selectAll(&#x27;text&#x27;)
            .style(&#x27;text-anchor&#x27;, &#x27;middle&#x27;);

        // draw x grid lines
        this.graph.selectAll(&#x27;.grid.x-grid&#x27;).remove();
        if (this.plotOptions.grid) {
            // draw the x grid lines
            this.graph.append(&#x27;svg:g&#x27;)
                .attr(&#x27;class&#x27;, &#x27;grid x-grid&#x27;)
                .attr(&#x27;transform&#x27;, &#x27;translate(0,&#x27; + this.height + &#x27;)&#x27;)
                .call(xAxis
                    .tickSize(-this.height)
                    .tickFormat(() &#x3D;&gt; &#x27;&#x27;)
                );
        }

        // draw upper axis as border
        this.graph.selectAll(&#x27;.x.axis.top&#x27;).remove();
        this.graph.append(&#x27;svg:g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;x axis top&#x27;)
            .call(d3.axisTop(this.xScaleBase).ticks(0).tickSize(0));

        // draw right axis as border
        this.graph.selectAll(&#x27;.y.axis.right&#x27;).remove();
        this.graph.append(&#x27;svg:g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;y axis right&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + this.width + &#x27;,0)&#x27;)
            .call(d3.axisRight(this.yScaleBase).tickFormat(() &#x3D;&gt; &#x27;&#x27;).tickSize(0));

        // text label for the x axis
        this.graph.selectAll(&#x27;.x.axis.label&#x27;).remove();
        if (this.plotOptions.showTimeLabel) {
            this.graph.append(&#x27;text&#x27;)
                .attr(&#x27;class&#x27;, &#x27;x axis label&#x27;)
                .attr(&#x27;x&#x27;, (this.width + bufferXrange) / 2)
                .attr(&#x27;y&#x27;, this.height + this.margin.bottom - 5)
                .style(&#x27;text-anchor&#x27;, &#x27;middle&#x27;)
                .text(&#x27;time&#x27;);
        }
    }

    /**
     * Function to draw the y axis for each dataset.
     * Each uom has its own axis.
     * @param axis {DataEntry} Object containing a dataset.
     */
    private drawYaxis(axis: YAxis) {
        let showAxis &#x3D; (this.plotOptions.overview ? false : (this.plotOptions.yaxis &#x3D;&#x3D;&#x3D; undefined ? true : this.plotOptions.yaxis));

        this.observer.forEach(e &#x3D;&gt; { if (e.adjustYAxis) { e.adjustYAxis(axis); } });

        // adjust to default extend
        axis.range &#x3D; this.rangeCalc.setDefaultExtendIfUndefined(axis.range);

        if (!axis.rangeFixed) { axis.range &#x3D; this.rangeCalc.bufferRange(axis.range); }

        // range for y axis scale
        const yScale &#x3D; d3.scaleLinear().domain([axis.range.min, axis.range.max]).range([this.height, 0]);

        const yAxisGen &#x3D; d3.axisLeft(yScale).ticks(TICKS_COUNT_YAXIS);
        let buffer &#x3D; 0;

        // only if yAxis should not be visible
        if (!showAxis) {
            yAxisGen
                .tickFormat(() &#x3D;&gt; &#x27;&#x27;)
                .tickSize(0);
        }

        // draw y axis
        const axisElem &#x3D; this.graph.append&lt;SVGSVGElement&gt;(&#x27;svg:g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;y axis&#x27;)
            .call(yAxisGen);

        // only if yAxis should be visible
        if (showAxis) {
            const axisHeight &#x3D; axisElem.node().getBBox().height;
            // draw y axis label
            const text &#x3D; this.graph.append&lt;SVGSVGElement&gt;(&#x27;text&#x27;)
                .attr(&#x27;transform&#x27;, &#x27;rotate(-90)&#x27;)
                .attr(&#x27;dy&#x27;, &#x27;1em&#x27;)
                .attr(&#x27;class&#x27;, &#x60;yaxisTextLabel ${axis.selected ? &#x27;selected&#x27; : &#x27;&#x27;}&#x60;)
                .text(axis.label ? (axis.uom + &#x27; @ &#x27; + axis.label) : axis.uom)
                .call(this.wrapText, axisHeight - 10, this.height / 2);

            const axisWidth &#x3D; axisElem.node().getBBox().width + 10 + this.graphHelper.getDimensions(text.node()).h;

            // if yAxis should not be visible, buffer will be set to 0
            buffer &#x3D; (showAxis ? axis.offset + (axisWidth &lt; this.margin.left ? this.margin.left : axisWidth) : 0);

            const axisWidthDiv &#x3D; (axisWidth &lt; this.margin.left ? this.margin.left : axisWidth);

            if (!axis.first) {
                axisElem.attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + buffer + &#x27;, 0)&#x27;);
            } else {
                buffer &#x3D; axisWidthDiv - this.margin.left;
                axisElem.attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + buffer + &#x27;, 0)&#x27;);
            }

            let textOff &#x3D; - (this.leftOffset);
            if (axis.first) {
                textOff &#x3D; this.margin.left;
            }
            text.attr(&#x27;y&#x27;, 0 - textOff);

            if (text) {
                let textWidth &#x3D; text.node().getBBox().width;
                let textHeight &#x3D; text.node().getBBox().height;
                let textPosition &#x3D; {
                    x: text.node().getBBox().x,
                    y: text.node().getBBox().y
                };
                let axisradius &#x3D; 4;
                let startOfPoints &#x3D; {
                    x: textPosition.y + textHeight / 2 + axisradius / 2, // + 2 because radius &#x3D;&#x3D;&#x3D; 4
                    y: Math.abs(textPosition.x + textWidth) - axisradius * 2
                };
                let pointOffset &#x3D; 0;

                axis.ids.forEach((entryID) &#x3D;&gt; {
                    let dataentry &#x3D; this.preparedData.find(el &#x3D;&gt; el.internalId &#x3D;&#x3D;&#x3D; entryID);
                    if (dataentry) {
                        if (dataentry.options.type) {
                            this.graphHelper.drawDatasetSign(this.graph, dataentry.options, startOfPoints.x, startOfPoints.y - pointOffset, dataentry.selected);
                        }
                        pointOffset +&#x3D; axisradius * 3 + (dataentry.selected ? 2 : 0);
                    }
                });

                const axisDiv &#x3D; this.graph.append(&#x27;rect&#x27;)
                    .attr(&#x27;class&#x27;, &#x60;y axisDiv ${axis.selected ? &#x27;selected&#x27; : &#x27;&#x27;}&#x60;)
                    .attr(&#x27;width&#x27;, axisWidthDiv)
                    .attr(&#x27;height&#x27;, this.height)
                    .on(&#x27;mouseup&#x27;, () &#x3D;&gt; this.highlightLine(axis.ids));

                if (!axis.first) {
                    axisDiv.attr(&#x27;x&#x27;, axis.offset).attr(&#x27;y&#x27;, 0);
                } else {
                    axisDiv.attr(&#x27;x&#x27;, 0 - this.margin.left - this.maxLabelwidth).attr(&#x27;y&#x27;, 0);
                }

                this.observer.forEach(e &#x3D;&gt; { if (e.afterYAxisDrawn) { e.afterYAxisDrawn(axis, buffer - axisWidth, axisHeight, axisWidth); } });
            }
        }

        return {
            buffer,
            yScale
        };
    }

    private drawBackground() {
        this.background &#x3D; this.graph.insert&lt;SVGSVGElement&gt;(&#x27;svg:rect&#x27;, &#x27;:first-child&#x27;)
            .attr(&#x27;width&#x27;, this.width - this.leftOffset)
            .attr(&#x27;height&#x27;, this.height)
            .attr(&#x27;class&#x27;, &#x27;graph-background&#x27;)
            .attr(&#x27;fill&#x27;, &#x27;none&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + this.leftOffset + &#x27;, 0)&#x27;);
    }

    /**
     * Function to set selected Ids that should be highlighted.
     * @param ids {Array} Array of Strings containing the Ids.
     */
    private highlightLine(ids: string[]): void {
        let changeFalse: HighlightDataset[] &#x3D; [];
        let changeTrue: HighlightDataset[] &#x3D; [];
        ids.forEach((ID) &#x3D;&gt; {
            if (this.selectedDatasetIds.indexOf(ID) &gt;&#x3D; 0) {
                changeFalse.push({ id: ID, change: false });
            }
            changeTrue.push({ id: ID, change: true });
        });

        if (ids.length &#x3D;&#x3D;&#x3D; changeFalse.length) {
            this.changeSelectedIds(changeFalse, true);
        } else {
            this.changeSelectedIds(changeTrue, false);
        }
    }

    /**
     * Function that changes state of selected Ids.
     */
    private changeSelectedIds(toHighlightDataset: HighlightDataset[], change: boolean): void {
        if (change) {
            toHighlightDataset.forEach((obj) &#x3D;&gt; {
                this.removeSelectedId(obj.id);
                this.selectedDatasetIds.splice(this.selectedDatasetIds.findIndex((entry) &#x3D;&gt; entry &#x3D;&#x3D;&#x3D; obj.id), 1);
            });
        } else {
            toHighlightDataset.forEach((obj) &#x3D;&gt; {
                if (this.selectedDatasetIds.indexOf(obj.id) &lt; 0) {
                    this.setSelectedId(obj.id);
                    this.selectedDatasetIds.push(obj.id);
                }
            });
        }

        this.onDatasetSelected.emit(this.selectedDatasetIds);
        this.redrawCompleteGraph();
    }

    /**
     * Function to draw the graph line for each dataset.
     * @param entry {DataEntry} Object containing a dataset.
     */
    protected drawChart(entry: InternalDataEntry): void {
        if (entry.data.length &gt; 0) {
            const yaxis &#x3D; this.yAxes.find(e &#x3D;&gt; e.ids.indexOf(entry.internalId) &gt;&#x3D; 0);
            if (yaxis) {
                // create body to clip graph
                // unique ID generated through the current time (current time when initialized)
                let querySelectorClip &#x3D; &#x27;clip&#x27; + this.currentTimeId;
                this.graph
                    .append(&#x27;svg:clipPath&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;diagram-path&#x27;)
                    .attr(&#x27;id&#x27;, querySelectorClip)
                    .append(&#x27;svg:rect&#x27;)
                    .attr(&#x27;x&#x27;, this.leftOffset)
                    .attr(&#x27;y&#x27;, 0)
                    .attr(&#x27;width&#x27;, this.width - this.leftOffset)
                    .attr(&#x27;height&#x27;, this.height);
                // draw graph line
                this.graphBody &#x3D; this.graph
                    .append(&#x27;g&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;diagram-path&#x27;)
                    .attr(&#x27;clip-path&#x27;, &#x27;url(#&#x27; + querySelectorClip + &#x27;)&#x27;);

                if (entry.options.type &#x3D;&#x3D;&#x3D; &#x27;bar&#x27;) {
                    this.drawBarChart(entry, yaxis.yScale);
                } else {
                    // draw ref value line
                    entry.referenceValueData.forEach(e &#x3D;&gt; this.drawRefLineChart(e.data, e.color, 1, yaxis.yScale));
                    this.drawLineChart(entry, yaxis.yScale);
                }
            }
        }
    }

    /**
     * Function that shows labeling via mousmove.
     */
    private mousemoveHandler &#x3D; (): void &#x3D;&gt; {
        const coords &#x3D; d3.mouse(this.background.node());
        this.labelTimestamp &#x3D; [];
        this.labelXCoord &#x3D; [];
        this.distLabelXCoord &#x3D; [];
        this.preparedData.forEach((entry, entryIdx) &#x3D;&gt; {
            const idx &#x3D; this.getItemForX(coords[0] + this.leftOffset, entry.data);
            this.showDiagramIndicator(entry, idx, coords[0], entryIdx);
        });

        let outputIds: string[] &#x3D; [];
        for (const key in this.highlightOutput.ids) {
            if (this.highlightOutput.ids.hasOwnProperty(key)) {
                outputIds.push(key);
            }
        }

        if (outputIds.length &lt;&#x3D; 0) {
            // do not show line in graph when no data available for timestamp
            this.focusG.style(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
        } else {
            let last &#x3D; 0,
                visible &#x3D; false,
                first &#x3D; true,
                labelArray: [d3.BaseType, d3.BaseType][] &#x3D; [],
                textRectArray: d3.BaseType[] &#x3D; d3.selectAll(&#x27;.focus-visibility&#x27;).nodes();

            // get and sort all text labels and rectangle of the text labels and combine related
            for (let i &#x3D; 0; i &lt; textRectArray.length; i +&#x3D; 2) {
                labelArray.push([textRectArray[i], textRectArray[i + 1]]);
            }
            // sory by y coordinate
            labelArray.sort((a, b) &#x3D;&gt; parseFloat(d3.select(a[0]).attr(&#x27;y&#x27;)) - parseFloat(d3.select(b[0]).attr(&#x27;y&#x27;)));

            // translate if overlapping
            labelArray.forEach((el) &#x3D;&gt; {
                // pairs of 2 objects (rectangle (equal) and label (odd))
                d3.select(el[0])
                    .attr(&#x27;transform&#x27;, (d, i, f) &#x3D;&gt; {
                        if (d3.select(el[0]).attr(&#x27;visibility&#x27;) !&#x3D;&#x3D; &#x27;hidden&#x27;) {
                            visible &#x3D; true;
                            let ycoord: number &#x3D; parseFloat(d3.select(el[0]).attr(&#x27;y&#x27;));
                            let offset &#x3D; 0;
                            if (!first) {
                                offset &#x3D; Math.max(0, (last + 30) - ycoord);
                                if (offset &lt; 10) { offset &#x3D; 10; }
                            }
                            if (offset &gt; 0) {
                                return &#x27;translate(0, &#x27; + offset + &#x27;)&#x27;;
                            }
                        }
                        return &#x27;translate(0, 0)&#x27;;
                    });

                d3.select(el[1])
                    .attr(&#x27;transform&#x27;, (d, i, f) &#x3D;&gt; {
                        if (d3.select(el[1]).attr(&#x27;visibility&#x27;) !&#x3D;&#x3D; &#x27;hidden&#x27;) {
                            visible &#x3D; true;
                            let ycoord: number &#x3D; parseFloat(d3.select(el[0]).attr(&#x27;y&#x27;));
                            let offset &#x3D; 0;
                            if (!first) {
                                offset &#x3D; Math.max(0, (last + 30) - ycoord);
                                if (offset &lt; 10) { offset &#x3D; 10; }
                            }
                            last &#x3D; offset + ycoord;
                            if (offset &gt; 0) {
                                return &#x27;translate(0, &#x27; + offset + &#x27;)&#x27;;
                            }
                        }
                        return &#x27;translate(0, 0)&#x27;;
                    });

                if (visible) {
                    first &#x3D; false;
                }

            });
        }
        this.onHighlightChanged.emit(this.highlightOutput);
    }

    /**
     * Function that hides the labeling inside the graph.
     */
    private mouseoutHandler &#x3D; (): void &#x3D;&gt; {
        this.hideDiagramIndicator();
    }

    private drawRefLineChart(data: DataEntry[], color: string, width: number, yScaleBase: d3.ScaleLinear&lt;number, number&gt;): void {
        let line &#x3D; this.createLine(this.xScaleBase, yScaleBase);

        this.graphBody
            .append(&#x27;svg:path&#x27;)
            .datum(data)
            .attr(&#x27;class&#x27;, &#x27;line&#x27;)
            .attr(&#x27;fill&#x27;, &#x27;none&#x27;)
            .attr(&#x27;stroke&#x27;, color)
            .attr(&#x27;stroke-width&#x27;, width)
            .attr(&#x27;d&#x27;, line);
    }

    private drawLineChart(entry: InternalDataEntry, yScaleBase: d3.ScaleLinear&lt;number, number&gt;) {
        const pointRadius &#x3D; this.calculatePointRadius(entry);

        // create graph line
        let line &#x3D; this.createLine(this.xScaleBase, yScaleBase);
        // draw line
        this.graphBody
            .append(&#x27;svg:path&#x27;)
            .datum(entry.data)
            .attr(&#x27;class&#x27;, &#x27;line&#x27;)
            .attr(&#x27;fill&#x27;, &#x27;none&#x27;)
            .attr(&#x27;stroke-dasharray&#x27;, entry.options.lineDashArray)
            .attr(&#x27;stroke&#x27;, entry.options.color)
            .attr(&#x27;stroke-width&#x27;, this.calculateLineWidth(entry))
            .attr(&#x27;d&#x27;, line);

        // draw line dots
        this.graphBody.selectAll(&#x27;.graphDots&#x27;)
            .data(entry.data.filter((d) &#x3D;&gt; typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;))
            .enter().append(&#x27;circle&#x27;)
            .attr(&#x27;class&#x27;, &#x27;graphDots&#x27;)
            .attr(&#x27;id&#x27;, (d: DataEntry) &#x3D;&gt; &#x27;dot-&#x27; + d.timestamp + &#x27;-&#x27; + entry.id)
            .attr(&#x27;stroke&#x27;, entry.options.pointBorderColor)
            .attr(&#x27;stroke-width&#x27;, entry.options.pointBorderWidth)
            .attr(&#x27;fill&#x27;, entry.options.color)
            .attr(&#x27;cx&#x27;, line.x())
            .attr(&#x27;cy&#x27;, line.y())
            .attr(&#x27;r&#x27;, pointRadius);

        if (this.plotOptions.hoverStyle &#x3D;&#x3D;&#x3D; HoveringStyle.point &amp;&amp; !this.plotOptions.overview) {
            this.graphBody.selectAll(&#x27;.hoverDots&#x27;)
                .data(entry.data.filter((d) &#x3D;&gt; typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;))
                .enter().append(&#x27;circle&#x27;)
                .attr(&#x27;class&#x27;, &#x27;hoverDots&#x27;)
                .attr(&#x27;id&#x27;, (d: DataEntry) &#x3D;&gt; &#x27;hover-dot-&#x27; + d.timestamp + &#x27;-&#x27; + entry.id)
                .attr(&#x27;stroke&#x27;, &#x27;transparent&#x27;)
                .attr(&#x27;fill&#x27;, &#x27;transparent&#x27;)
                .attr(&#x27;cx&#x27;, line.x())
                .attr(&#x27;cy&#x27;, line.y())
                .attr(&#x27;r&#x27;, pointRadius + 3)
                .on(&#x27;mouseover&#x27;, (d: DataEntry) &#x3D;&gt; this.mouseOverPointHovering(d, entry))
                .on(&#x27;mouseout&#x27;, (d: DataEntry) &#x3D;&gt; this.mouseOutPointHovering(d, entry))
                .on(&#x27;mousedown&#x27;, (d: DataEntry) &#x3D;&gt; this.clickDataPoint(d, entry));
        }
    }

    private drawBarChart(entry: InternalDataEntry, yScaleBase: d3.ScaleLinear&lt;number, number&gt;) {
        const paddingBefore &#x3D; 0;
        const paddingAfter &#x3D; 5;
        const periodInMs &#x3D; entry.bar.period.asMilliseconds();

        const bars &#x3D; this.graphBody.selectAll(&#x27;.bar&#x27;)
            .data(entry.data)
            .enter().append(&#x27;rect&#x27;)
            .attr(&#x27;class&#x27;, &#x27;bar&#x27;)
            .style(&#x27;fill&#x27;, entry.options.color)
            .style(&#x27;stroke-dasharray&#x27;, entry.options.lineDashArray)
            .style(&#x27;stroke&#x27;, entry.options.color)
            .style(&#x27;stroke-width&#x27;, this.calculateLineWidth(entry))
            .style(&#x27;fill-opacity&#x27;, 0.5)
            .attr(&#x27;x&#x27;, (d: DataEntry) &#x3D;&gt; this.xScaleBase(d.timestamp) + paddingBefore)
            .attr(&#x27;width&#x27;, (d: DataEntry) &#x3D;&gt; {
                let width &#x3D; 10;
                if (typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
                    width &#x3D; this.xScaleBase(d.timestamp + periodInMs) - this.xScaleBase(d.timestamp);
                }
                return width - paddingBefore - paddingAfter;
            })
            .attr(&#x27;y&#x27;, (d: DataEntry) &#x3D;&gt; typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27; ? yScaleBase(d.value) : 0)
            .attr(&#x27;height&#x27;, (d: DataEntry) &#x3D;&gt; (typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) ? this.height - yScaleBase(d.value) : 0);

        if (this.plotOptions.hoverStyle &#x3D;&#x3D;&#x3D; HoveringStyle.point) {
            bars
                .on(&#x27;mouseover&#x27;, (d: { value: number, timestamp: number }, idx: number, rectElems: any[]) &#x3D;&gt; this.mouseoverBarHovering(d, rectElems, idx, entry))
                .on(&#x27;mousemove&#x27;, (d: { value: number, timestamp: number }) &#x3D;&gt; this.mousemoveBarHovering(d, entry))
                .on(&#x27;mouseout&#x27;, (d: { value: number, timestamp: number }, idx: number, rectElems: any[]) &#x3D;&gt; this.mouseoutBarHovering(d, rectElems, idx, entry));
        }
    }

    private hideHoveringLabel() {
        if (this.highlightRect) { this.highlightRect.style(&#x27;visibility&#x27;, &#x27;hidden&#x27;); }
        if (this.highlightText) { this.highlightText.style(&#x27;visibility&#x27;, &#x27;hidden&#x27;); }
    }

    private showHoveringLabel() {
        if (this.highlightRect) { this.highlightRect.style(&#x27;visibility&#x27;, &#x27;visible&#x27;); }
        if (this.highlightText) { this.highlightText.style(&#x27;visibility&#x27;, &#x27;visible&#x27;); }
    }

    private mouseoverBarHovering(d: { value: number; timestamp: number; }, rectElems: any[], idx: number, entry: InternalDataEntry) {
        if (d !&#x3D;&#x3D; undefined) {
            let coords &#x3D; d3.mouse(this.background.node());
            let xCoord &#x3D; coords[0];
            let yCoord &#x3D; coords[1];
            let rectBack &#x3D; this.background.node().getBBox();
            if (xCoord &gt;&#x3D; 0 &amp;&amp; xCoord &lt;&#x3D; rectBack.width &amp;&amp; yCoord &gt;&#x3D; 0 &amp;&amp; yCoord &lt;&#x3D; rectBack.height) {
                // highlight bar
                d3.select(rectElems[idx]).style(&#x27;stroke-width&#x27;, this.calculateLineWidth(entry) + 2);

                this.showHoveringLabel();

                this.setHoveringLabel(d.value, d.timestamp, entry.axisOptions.uom);

                this.positioningHoverLabel(xCoord, yCoord, entry.options.color);
                // generate output of highlighted data
                this.highlightOutput &#x3D; {
                    timestamp: d.timestamp,
                    ids: new Map().set(entry.internalId, { timestamp: d.timestamp, value: d.value })
                };
                this.onHighlightChanged.emit(this.highlightOutput);
            }
        }
    }

    private mousemoveBarHovering(d: { value: number; timestamp: number; }, entry: InternalDataEntry) {
        const temp &#x3D; new Date().getTime();
        if (d !&#x3D;&#x3D; undefined &amp;&amp; (temp - this.lastHoverPositioning &gt; 50)) {
            let coords &#x3D; d3.mouse(this.background.node());
            let xCoord &#x3D; coords[0];
            let yCoord &#x3D; coords[1];
            this.positioningHoverLabel(xCoord, yCoord, entry.options.color);
        }
    }

    private mouseoutBarHovering(d: { value: number; timestamp: number; }, rectElems: any[], idx: number, entry: InternalDataEntry) {
        if (d !&#x3D;&#x3D; undefined) {
            // unhighlight hovered dot
            d3.select(rectElems[idx])
                .style(&#x27;stroke-width&#x27;, this.calculateLineWidth(entry));
            // make label invisible
            this.hideHoveringLabel();
        }
    }

    private positioningHoverLabel(x: number, y: number, color: string) {
        let onLeftSide &#x3D; false;
        if ((this.background.node().getBBox().width + this.leftOffset) / 2 &gt; x) {
            onLeftSide &#x3D; true;
        }
        let rectX: number &#x3D; x + 15;
        let rectY: number &#x3D; y;
        let rectW: number &#x3D; this.graphHelper.getDimensions(this.highlightText.node()).w + 8;
        let rectH: number &#x3D; this.graphHelper.getDimensions(this.highlightText.node()).h;
        if (!onLeftSide) {
            rectX &#x3D; x - 15 - rectW;
            rectY &#x3D; y;
        }
        if ((y + rectH + 4) &gt; this.background.node().getBBox().height) {
            rectY &#x3D; rectY - rectH;
        }
        // create hovering label
        let dotRectangle &#x3D; this.highlightRect
            .attr(&#x27;class&#x27;, &#x27;mouseHoverDotRect&#x27;)
            .style(&#x27;fill&#x27;, &#x27;white&#x27;)
            .style(&#x27;fill-opacity&#x27;, 1)
            .style(&#x27;stroke&#x27;, color)
            .style(&#x27;stroke-width&#x27;, &#x27;1px&#x27;)
            .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
            .attr(&#x27;width&#x27;, rectW)
            .attr(&#x27;height&#x27;, rectH)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + rectX + &#x27;, &#x27; + rectY + &#x27;)&#x27;);
        let labelX: number &#x3D; x + 4 + 15;
        let labelY: number &#x3D; y + this.graphHelper.getDimensions(dotRectangle.node()).h - 4;
        if (!onLeftSide) {
            labelX &#x3D; x - rectW + 4 - 15;
            labelY &#x3D; y + this.graphHelper.getDimensions(dotRectangle.node()).h - 4;
        }
        if ((y + rectH + 4) &gt; this.background.node().getBBox().height) {
            labelY &#x3D; labelY - rectH;
        }
        this.highlightText.attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + labelX + &#x27;, &#x27; + labelY + &#x27;)&#x27;);
        this.lastHoverPositioning &#x3D; new Date().getTime();
    }

    private createLine(xScaleBase: d3.ScaleTime&lt;number, number&gt;, yScaleBase: d3.ScaleLinear&lt;number, number&gt;) {
        return d3.line&lt;DataEntry&gt;()
            .defined((d) &#x3D;&gt; typeof d.timestamp &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;)
            .x((d) &#x3D;&gt; {
                const xDiagCoord &#x3D; xScaleBase(d.timestamp);
                if (!isNaN(xDiagCoord)) {
                    d.xDiagCoord &#x3D; xDiagCoord;
                    return xDiagCoord;
                }
            })
            .y((d) &#x3D;&gt; {
                if (typeof d.value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
                    const yDiagCoord &#x3D; yScaleBase(d.value);
                    if (!isNaN(yDiagCoord)) {
                        d.yDiagCoord &#x3D; yDiagCoord;
                        return yDiagCoord;
                    } else {
                        // return value to avoid error with NaN in linepath while drag and drop in Google Chrome
                        return 0;
                    }
                }
            })
            .curve(d3.curveLinear);
    }

    private mouseOverPointHovering(d: DataEntry, entry: InternalDataEntry) {
        if (d !&#x3D;&#x3D; undefined) {
            let coords &#x3D; d3.mouse(this.background.node());
            let xCoord &#x3D; coords[0];
            let yCoord &#x3D; coords[1];
            let rectBack &#x3D; this.background.node().getBBox();
            if (coords[0] &gt;&#x3D; 0 &amp;&amp; coords[0] &lt;&#x3D; rectBack.width &amp;&amp; coords[1] &gt;&#x3D; 0 &amp;&amp; coords[1] &lt;&#x3D; rectBack.height) {
                // highlight hovered dot
                d3.select(&#x27;#dot-&#x27; + d.timestamp + &#x27;-&#x27; + entry.id)
                    .attr(&#x27;opacity&#x27;, 0.8)
                    .attr(&#x27;r&#x27;, this.calculatePointRadius(entry) + 3);

                this.showHoveringLabel();

                this.setHoveringLabel(d.value, d.timestamp, entry.axisOptions.uom);

                this.positioningHoverLabel(xCoord, yCoord, entry.options.color);

                this.highlightOutput &#x3D; {
                    timestamp: d.timestamp,
                    ids: new Map().set(entry.internalId, { timestamp: d.timestamp, value: d.value })
                };
                this.onHighlightChanged.emit(this.highlightOutput);
            }
        }
    }

    private setHoveringLabel(value: number | string, timestamp: number, uom: string) {
        let stringedValue &#x3D; (typeof value &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) ? parseFloat(value.toPrecision(15)).toString() : value;
        this.highlightText
            .text(&#x60;${stringedValue} ${uom} ${moment(timestamp).format(&#x27;DD.MM.YY HH:mm&#x27;)}&#x60;)
            .attr(&#x27;class&#x27;, &#x27;mouseHoverDotLabel&#x27;)
            .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
            .style(&#x27;fill&#x27;, &#x27;black&#x27;);
    }

    private mouseOutPointHovering(d: DataEntry, entry: InternalDataEntry) {
        if (d !&#x3D;&#x3D; undefined) {
            // unhighlight hovered dot
            d3.select(&#x27;#dot-&#x27; + d.timestamp + &#x27;-&#x27; + entry.id)
                .attr(&#x27;opacity&#x27;, 1)
                .attr(&#x27;r&#x27;, this.calculatePointRadius(entry));
            this.hideHoveringLabel();
        }
    }

    /**
     * Function that returns the metadata of a specific entry in the dataset.
     * @param x {Number} Coordinates of the mouse inside the diagram.
     * @param data {DataEntry} Array with the data of each dataset entry.
     */
    private getItemForX(x: number, data: DataEntry[]): number {
        const index &#x3D; this.xScaleBase.invert(x);
        const bisectDate &#x3D; d3.bisector((d: DataEntry) &#x3D;&gt; d.timestamp).left;
        return bisectDate(data, index);
    }

    /**
     * Function that disables the labeling.
     */
    private hideDiagramIndicator(): void {
        this.focusG.style(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
        d3.selectAll(&#x27;.focus-visibility&#x27;)
            .attr(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
    }

    /**
     * Function that enables the lableing of each dataset entry.
     * @param entry {InternalDataEntry} Object containing the dataset.
     * @param idx {Number} Number with the position of the dataset entry in the data array.
     * @param xCoordMouse {Number} Number of the x coordinate of the mouse.
     * @param entryIdx {Number} Number of the index of the entry.
     */
    private showDiagramIndicator &#x3D; (entry: InternalDataEntry, idx: number, xCoordMouse: number, entryIdx: number): void &#x3D;&gt; {
        const item: DataEntry &#x3D; entry.data[idx];
        this.labelXCoord[entryIdx] &#x3D; null;
        this.distLabelXCoord[entryIdx] &#x3D; null;

        if (item !&#x3D;&#x3D; undefined &amp;&amp; item.yDiagCoord &amp;&amp; item.value !&#x3D;&#x3D; undefined) {
            // create line where mouse is
            this.focusG.style(&#x27;visibility&#x27;, &#x27;visible&#x27;);
            // show label if data available for time
            this.chVisLabel(entry, true, entryIdx);

            let xMouseAndBuffer &#x3D; xCoordMouse + this.leftOffset;
            let labelBuffer &#x3D; ((this.timespan.from / (this.timespan.to - this.timespan.from)) * 0.0001)
                * ((this.timespan.from / (this.timespan.to - this.timespan.from)) * 0.0001);

            labelBuffer &#x3D; Math.max(10, labelBuffer);

            this.showLabelValues(entry, item);
            this.showTimeIndicatorLabel(item, entryIdx, xMouseAndBuffer);

            if (item.xDiagCoord &gt;&#x3D; this.background.node().getBBox().width + this.leftOffset || xMouseAndBuffer &lt; item.xDiagCoord - labelBuffer) {
                this.chVisLabel(entry, false, entryIdx);
            }

            if (xMouseAndBuffer &lt; item.xDiagCoord) {
                if (entry.data[idx - 1] &amp;&amp; (Math.abs(entry.data[idx - 1].xDiagCoord - xMouseAndBuffer) &lt; Math.abs(item.xDiagCoord - xMouseAndBuffer))) {
                    this.chVisLabel(entry, false, entryIdx);
                    // show closest element to mouse
                    this.showLabelValues(entry, entry.data[idx - 1]);
                    this.showTimeIndicatorLabel(entry.data[idx - 1], entryIdx, xMouseAndBuffer);
                    this.chVisLabel(entry, true, entryIdx);

                    // check for graph width and range between data point and mouse
                    if (entry.data[idx - 1].xDiagCoord &gt;&#x3D; this.background.node().getBBox().width + this.leftOffset
                        || entry.data[idx - 1].xDiagCoord &lt;&#x3D; this.leftOffset
                        || entry.data[idx - 1].xDiagCoord + labelBuffer &lt; xMouseAndBuffer) {
                        this.chVisLabel(entry, false, entryIdx);
                    }
                }
            }
        } else {
            // TODO: set hovering for labelbuffer after last and before first value of the graph
            // hide label if no data available for time
            this.chVisLabel(entry, false, entryIdx);
        }
    }

    /**
     * Function to change visibility of label and white rectangle inside graph (next to mouse-cursor line).
     * @param entry {DataEntry} Object containing the dataset.
     * @param visible {Boolean} Boolean giving information about visibility of a label.
     */
    private chVisLabel(entry: InternalDataEntry, visible: boolean, entryIdx: number): void {
        if (visible) {
            entry.focusLabel
                .attr(&#x27;visibility&#x27;, &#x27;visible&#x27;)
                .attr(&#x27;class&#x27;, &#x27;focus-visibility&#x27;);
            entry.focusLabelRect
                .attr(&#x27;visibility&#x27;, &#x27;visible&#x27;)
                .attr(&#x27;class&#x27;, &#x27;focus-visibility&#x27;);
        } else {
            entry.focusLabel
                .attr(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
            entry.focusLabelRect
                .attr(&#x27;visibility&#x27;, &#x27;hidden&#x27;);

            this.labelTimestamp[entryIdx] &#x3D; null;
            delete this.highlightOutput.ids[entry.internalId];
        }
    }

    /**
     * Function to show the labeling inside the graph.
     * @param entry {DataEntry} Object containg the dataset.
     * @param item {DataEntry} Object of the entry in the dataset.
     */
    private showLabelValues(entry: InternalDataEntry, item: DataEntry): void {
        let onLeftSide: boolean &#x3D; this.checkLeftSide(item.xDiagCoord);
        if (entry.focusLabel) {
            entry.focusLabel.text(item.value + (entry.axisOptions.uom ? entry.axisOptions.uom : &#x27;&#x27;));
            const entryX: number &#x3D; onLeftSide ?
                item.xDiagCoord + 4 : item.xDiagCoord - this.graphHelper.getDimensions(entry.focusLabel.node()).w + 4;
            entry.focusLabel
                .attr(&#x27;x&#x27;, entryX)
                .attr(&#x27;y&#x27;, item.yDiagCoord);
            entry.focusLabelRect
                .attr(&#x27;x&#x27;, entryX)
                .attr(&#x27;y&#x27;, item.yDiagCoord - this.graphHelper.getDimensions(entry.focusLabel.node()).h + 3)
                .attr(&#x27;width&#x27;, this.graphHelper.getDimensions(entry.focusLabel.node()).w)
                .attr(&#x27;height&#x27;, this.graphHelper.getDimensions(entry.focusLabel.node()).h);

            this.highlightOutput.ids[entry.internalId] &#x3D; {
                &#x27;timestamp&#x27;: item.timestamp,
                &#x27;value&#x27;: item.value
            };
        } else {
            delete this.highlightOutput.ids[entry.internalId];
        }
    }

    /**
     * Function to show the time labeling inside the graph.
     * @param item {DataEntry} Object of the entry in the dataset.
     * @param entryIdx {Number} Number of the index of the entry.
     */
    private showTimeIndicatorLabel(item: DataEntry, entryIdx: number, mouseCoord: number): void {
        // timestamp is the time where the mouse-cursor is
        this.labelTimestamp[entryIdx] &#x3D; item.timestamp;
        this.labelXCoord[entryIdx] &#x3D; item.xDiagCoord;
        this.distLabelXCoord[entryIdx] &#x3D; Math.abs(mouseCoord - item.xDiagCoord);
        let minXcoord &#x3D; d3.min(this.distLabelXCoord);
        let idxOfMin &#x3D; this.distLabelXCoord.findIndex((elem) &#x3D;&gt; elem &#x3D;&#x3D;&#x3D; minXcoord);
        let onLeftSide &#x3D; this.checkLeftSide(item.xDiagCoord);
        let right &#x3D; this.labelXCoord[idxOfMin] + 2;
        let left &#x3D; this.labelXCoord[idxOfMin] - this.graphHelper.getDimensions(this.focuslabelTime.node()).w - 2;
        this.focuslabelTime.text(moment(this.labelTimestamp[idxOfMin]).format(&#x27;DD.MM.YY HH:mm&#x27;));
        this.focuslabelTime
            .attr(&#x27;x&#x27;, onLeftSide ? right : left)
            .attr(&#x27;y&#x27;, 13);
        this.highlightFocus
            .attr(&#x27;x1&#x27;, this.labelXCoord[idxOfMin])
            .attr(&#x27;y1&#x27;, 0)
            .attr(&#x27;x2&#x27;, this.labelXCoord[idxOfMin])
            .attr(&#x27;y2&#x27;, this.height)
            .classed(&#x27;hidden&#x27;, false);
        this.highlightOutput.timestamp &#x3D; this.labelTimestamp[idxOfMin];
    }

    /**
     * Function giving information if the mouse is on left side of the diagram.
     * @param itemCoord {number} x coordinate of the value (e.g. mouse) to be checked
     */
    private checkLeftSide(itemCoord: number): boolean {
        return ((this.background.node().getBBox().width + this.leftOffset) / 2 &gt; itemCoord) ? true : false;
    }

    /**
     * Function to wrap the text for the y axis label.
     * @param text {any} y axis label
     * @param width {Number} width of the axis which must not be crossed
     * @param xposition {Number} position to center the label in the middle
     */
    private wrapText(textObj: any, width: number, xposition: number): void {
        textObj.each(function (u: any, i: number, d: NodeList) {
            let text &#x3D; d3.select(this),
                words &#x3D; text.text().split(/\s+/).reverse(),
                word,
                line &#x3D; [],
                // lineNumber &#x3D; 0,
                lineHeight &#x3D; (i &#x3D;&#x3D;&#x3D; d.length - 1 ? 0.3 : 1.1), // ems
                y &#x3D; text.attr(&#x27;y&#x27;),
                dy &#x3D; parseFloat(text.attr(&#x27;dy&#x27;)),
                tspan &#x3D; text.text(null).append(&#x27;tspan&#x27;).attr(&#x27;x&#x27;, 0 - xposition).attr(&#x27;y&#x27;, y).attr(&#x27;dy&#x27;, dy + &#x27;em&#x27;);
            while (word &#x3D; words.pop()) {
                line.push(word);
                tspan.text(line.join(&#x27; &#x27;));
                let node: SVGTSpanElement &#x3D; &lt;SVGTSpanElement&gt;tspan.node();
                let hasGreaterWidth: boolean &#x3D; node.getComputedTextLength() &gt; width;
                if (hasGreaterWidth) {
                    line.pop();
                    tspan.text(line.join(&#x27; &#x27;));
                    line &#x3D; [word];
                    tspan &#x3D; text.append(&#x27;tspan&#x27;).attr(&#x27;x&#x27;, 0 - xposition).attr(&#x27;y&#x27;, y).attr(&#x27;dy&#x27;, lineHeight + dy + &#x27;em&#x27;).text(word);
                }
            }
        });
    }

    /**
     * Function to generate uuid for a diagram
     */
    private uuidv4(): string {
        return this.s4() + this.s4() + &#x27;-&#x27; + this.s4() + &#x27;-&#x27; + this.s4() + &#x27;-&#x27; + this.s4() + &#x27;-&#x27; + this.s4() + this.s4() + this.s4();
    }

    /**
     * Function to generate components of the uuid for a diagram
     */
    private s4(): string {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }

    /**
     * Function that logs the error in the console.
     * @param error {Object} Object with the error.
     */
    private onError(error: any): void {
        console.error(error);
    }

    private calculateLineWidth(entry: InternalDataEntry): number {
        if (entry.selected) {
            return entry.options.lineWidth + this.addLineWidth;
        } else {
            return entry.options.lineWidth;
        }
    }

    private calculatePointRadius(entry: InternalDataEntry) {
        if (entry.selected) {
            return entry.options.pointRadius &gt; 0 ? entry.options.pointRadius + this.addLineWidth : entry.options.pointRadius;
        } else {
            return entry.options.pointRadius;
        }
    }
}

</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'HighlightDataset.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
