<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>helgoland-toolbox documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">helgoland-toolbox documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search">
</div>
            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>YAxisSelection</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/helgoland/d3/src/lib/d3-timeseries-graph/d3-timeseries-graph.component.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#clicked">clicked</a>
                                </li>
                                <li>
                                        <a href="#id">id</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#ids">ids</a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#uom">uom</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="clicked"></a>
                                        <span class="name"><b>clicked</b><a href="#clicked"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>clicked:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="id"></a>
                                        <span class="name"><b>id</b><a href="#id"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>id:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="ids"></a>
                                        <span class="name"><b>ids</b><a href="#ids"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>ids:     <code>Array&lt;string&gt;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Array&lt;string&gt;</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="uom"></a>
                                        <span class="name"><b>uom</b><a href="#uom"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>uom:     <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { AfterViewInit, Component, ElementRef, Input, IterableDiffers, ViewChild, ViewEncapsulation } from &#x27;@angular/core&#x27;;
import {
    ColorService,
    Data,
    DatasetApiInterface,
    DatasetOptions,
    DatasetPresenterComponent,
    IDataset,
    InternalIdHandler,
    MinMaxRange,
    Time,
    Timeseries,
    Timespan,
} from &#x27;@helgoland/core&#x27;;
import { LangChangeEvent, TranslateService } from &#x27;@ngx-translate/core&#x27;;
import * as d3 from &#x27;d3&#x27;;
import moment from &#x27;moment&#x27;;
import { Observable } from &#x27;rxjs/Observable&#x27;;
import { Observer } from &#x27;rxjs/Observer&#x27;;

import { D3TimeFormatLocaleService } from &#x27;../helper/d3-time-format-locale.service&#x27;;
import { D3PlotOptions } from &#x27;../model/d3-plot-options&#x27;;

interface DataEntry {
    yDiagCoord?: number;
    timestamp?: number;
    xDiagMin?: number;
    xDiagMax?: number;
    yDiagMin?: number;
    yDiagMax?: number;
    xDiagCoord?: number;
}

interface HighlightDataset {
    id: string;
    change: boolean;
}

interface YScale {
    buffer: number;
    yScale: d3.ScaleLinear&lt;number, number&gt;;
}

export interface YRanges {
    uom: string;
    range: MinMaxRange;
    preRange: MinMaxRange;
    originRange: MinMaxRange;
    zeroBased: boolean;
    autoRange: boolean;
    outOfrange: boolean;
    ids: string[];
    first?: boolean;
    yScale?: d3.ScaleLinear&lt;number, number&gt;;
    offset?: number;
}

export interface InternalDataEntry {
    internalId: string;
    color: string;
    data: [number, number][];
    points: {
        fillColor: string
    };
    lines: {
        lineWidth: number;
        pointRadius: number;
    };
    bars: {
        lineWidth: number;
    };
    axisOptions: {
        uom: string;
        label: string;
        zeroBased: boolean;
        yAxisRange: MinMaxRange;
        autoRangeSelection: boolean;
        separateYAxis: boolean;
    };
    visible: boolean;
}

export interface DataYRange {
    uom: string;
    range?: MinMaxRange;
    preRange?: MinMaxRange;
    originRange?: MinMaxRange;
    id: string;
    zeroBasedYAxis: boolean;
    autoRange: boolean;
    outOfrange: boolean;
}

export interface DataConst extends IDataset {
    data?: Data&lt;[number, number]&gt;;
}

interface YAxisSelection {
    id: string;
    clicked: boolean;
    ids?: Array&lt;string&gt;;
    uom?: string;
}

@Component({
    selector: &#x27;n52-d3-timeseries-graph&#x27;,
    templateUrl: &#x27;./d3-timeseries-graph.component.html&#x27;,
    styleUrls: [&#x27;./d3-timeseries-graph.component.scss&#x27;],
    encapsulation: ViewEncapsulation.None
})
export class D3TimeseriesGraphComponent
    extends DatasetPresenterComponent&lt;DatasetOptions, D3PlotOptions&gt;
    implements AfterViewInit {

    @Input()
    // difference to timespan/timeInterval --&gt; if brush, then this is the timespan of the main-diagram
    public mainTimeInterval: Timespan;

    @ViewChild(&#x27;d3timeseries&#x27;)
    public d3Elem: ElementRef;

    // set zoom limit --&gt; can be adapted to needs
    private config &#x3D; {
        time: {
            zoomLimit: 10800000  // 3 hour ((3 * 3600) * 1000) limitation
        }
    };

    protected preparedData &#x3D; []; // : DataSeries[]
    private mousedownBrush: boolean;
    protected rawSvg: any; // d3.Selection&lt;EnterElement, {}, null, undefined&gt;;
    protected graph: any;
    private graphBody: any;
    private dragRect: any;
    private dragRectG: any;
    private xAxisRange: Timespan; // x domain range
    private xAxisRangeOrigin: any; // x domain range
    private xAxisRangePan: [number, number]; // x domain range
    protected yRangesEachUom: YRanges[] &#x3D; []; // y array of objects containing ranges for each uom
    protected dataYranges: DataYRange[]; // y array of objects containing ranges of all datasets
    private ypos: any; // y array of objects containing ranges of all datasets
    private idxOfPos &#x3D; 0;

    private listOfUoms &#x3D; Array();
    private listOfSeparation &#x3D; Array();

    private height: number;
    private width: number;
    private margin &#x3D; {
        top: 10,
        right: 10,
        bottom: 40,
        left: 40
    };
    private maxLabelwidth &#x3D; 0;
    private xScaleBase: d3.ScaleTime&lt;number, number&gt;; // calculate diagram coord of x value
    private yScaleBase: d3.ScaleLinear&lt;number, number&gt;; // calculate diagram coord of y value
    private background: any;
    private copyright: any;
    private focusG: any;
    private highlightFocus: any;
    private focuslabelTime: any;
    private bufferSum: number;
    private labelTimestamp: number[];

    private dragging: boolean;
    private dragStart: [number, number];
    private dragCurrent: [number, number];

    private draggingMove: boolean;
    private dragMoveStart: [number, number];
    private dragMoveRange: [number, number];

    private yAxisSelect;
    private opac &#x3D; {
        default: 0,
        hover: 0.3,
        click: 0.5
    };

    private addLineWidth &#x3D; 2; // value added to linewidth

    // default plot options
    private plotOptions: D3PlotOptions &#x3D; {
        showReferenceValues: false,
        generalizeAllways: true,
        togglePanZoom: true,
        hoverable: true,
        grid: true,
        yaxis: true,
        overview: false
    };

    private oldGroupYaxis;

    protected datasetMap: Map&lt;string, DataConst&gt; &#x3D; new Map();

    private loadingCounter &#x3D; 0;
    private currentTimeId: string;

    constructor(
        protected iterableDiffers: IterableDiffers,
        protected api: DatasetApiInterface,
        protected datasetIdResolver: InternalIdHandler,
        protected timeSrvc: Time,
        protected timeFormatLocaleService: D3TimeFormatLocaleService,
        protected colorService: ColorService,
        protected translateService: TranslateService
    ) {
        super(iterableDiffers, api, datasetIdResolver, timeSrvc, translateService);
    }

    public ngAfterViewInit(): void {
        this.currentTimeId &#x3D; this.uuidv4();

        this.rawSvg &#x3D; d3.select(this.d3Elem.nativeElement)
            .append(&#x27;svg&#x27;)
            .attr(&#x27;width&#x27;, &#x27;100%&#x27;)
            .attr(&#x27;height&#x27;, &#x27;100%&#x27;);

        this.graph &#x3D; this.rawSvg
            .append(&#x27;g&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + (this.margin.left + this.maxLabelwidth) + &#x27;,&#x27; + this.margin.top + &#x27;)&#x27;);

        this.mousedownBrush &#x3D; false;
        this.dataYranges &#x3D; [];
        this.xAxisRangeOrigin &#x3D; [];
    }

    protected onLanguageChanged(langChangeEvent: LangChangeEvent): void {
        this.plotGraph();
    }

    public reloadDataForDatasets(datasetIds: string[]): void {
        datasetIds.forEach(id &#x3D;&gt; {
            if (this.datasetMap.has(id)) {
                this.loadDatasetData(this.datasetMap.get(id), true);
            }
        });
    }

    protected addDataset(id: string, url: string): void {
        this.api.getSingleTimeseries(id, url).subscribe(
            (timeseries) &#x3D;&gt; this.loadAddedDataset(timeseries),
            (error) &#x3D;&gt; {
                this.api.getDataset(id, url).subscribe(
                    (dataset) &#x3D;&gt; this.loadAddedDataset(dataset),
                );
            }
        );
    }
    protected removeDataset(internalId: string): void {
        this.dataYranges &#x3D; [];
        this.xAxisRangeOrigin &#x3D; [];
        this.datasetMap.delete(internalId);
        let spliceIdx &#x3D; this.preparedData.findIndex((entry) &#x3D;&gt; entry.internalId &#x3D;&#x3D;&#x3D; internalId);
        if (spliceIdx &gt;&#x3D; 0) {
            this.preparedData.splice(spliceIdx, 1);
            if (this.preparedData.length &lt;&#x3D; 0) {
                this.yRangesEachUom &#x3D; [];
                this.plotGraph();
            } else {
                this.preparedData.forEach((entry, idx) &#x3D;&gt; {
                    this.processData(entry);
                });
            }
        }
    }
    protected setSelectedId(internalId: string): void {
        const tsData &#x3D; this.preparedData.find((e) &#x3D;&gt; e.internalId &#x3D;&#x3D;&#x3D; internalId);
        if (!tsData.selected || tsData.selected &#x3D;&#x3D;&#x3D; undefined) {
            tsData.selected &#x3D; true;
            tsData.lines.lineWidth +&#x3D; this.addLineWidth;
            tsData.lines.pointRadius +&#x3D; this.addLineWidth;
            tsData.bars.lineWidth +&#x3D; this.addLineWidth;

            let identifier &#x3D; (this.plotOptions.groupYaxis ? tsData.axisOptions.uom : tsData.internalId);
            this.checkYselector(identifier, tsData.axisOptions.uom);
            this.yAxisSelect[identifier].clicked &#x3D; true;
            this.yAxisSelect[identifier].ids.push(internalId);

            if (tsData.axisOptions.separateYAxis) {
                this.checkYselector(tsData.internalId, tsData.axisOptions.uom);
                if (this.yAxisSelect[internalId]) {
                    this.yAxisSelect[internalId].clicked &#x3D; true;
                }
            }
        }
        this.plotGraph();
    }
    protected removeSelectedId(internalId: string): void {
        const tsData &#x3D; this.preparedData.find((e) &#x3D;&gt; e.internalId &#x3D;&#x3D;&#x3D; internalId);
        if (tsData.selected || tsData.selected &#x3D;&#x3D;&#x3D; undefined) {
            tsData.selected &#x3D; false;
            tsData.lines.lineWidth -&#x3D; this.addLineWidth;
            tsData.lines.pointRadius -&#x3D; this.addLineWidth;
            tsData.bars.lineWidth -&#x3D; this.addLineWidth;

            let identifier &#x3D; (this.plotOptions.groupYaxis ? tsData.axisOptions.uom : tsData.internalId);
            this.checkYselector(identifier, tsData.axisOptions.uom);
            this.yAxisSelect[identifier].ids &#x3D; this.yAxisSelect[identifier].ids.filter(el &#x3D;&gt; el !&#x3D;&#x3D; internalId);
            if (this.yAxisSelect[identifier].ids.length &lt;&#x3D; 0) {
                this.yAxisSelect[identifier].clicked &#x3D; false;
            } else {
                this.yAxisSelect[identifier].clicked &#x3D; true;
            }
            if (tsData.axisOptions.separateYAxis) {
                this.checkYselector(tsData.internalId, tsData.axisOptions.uom);
                if (this.yAxisSelect[tsData.internalId]) {
                    this.yAxisSelect[tsData.internalId].clicked &#x3D; false;
                }
            }
        }
        this.plotGraph();
    }
    protected graphOptionsChanged(options: D3PlotOptions): void {
        this.oldGroupYaxis &#x3D; this.plotOptions.groupYaxis;

        Object.assign(this.plotOptions, options);
        if (this.rawSvg &amp;&amp; this.yRangesEachUom) {
            this.plotGraph();
        }
    }
    protected datasetOptionsChanged(internalId: string, options: DatasetOptions, firstChange: boolean) {
        if (!firstChange &amp;&amp; this.datasetMap.has(internalId)) {
            this.loadDatasetData(this.datasetMap.get(internalId), false);
        }
    }
    protected timeIntervalChanges(): void {
        this.datasetMap.forEach((dataset) &#x3D;&gt; {
            this.loadDatasetData(dataset, false);
        });
    }
    protected onResize(): void {
        this.plotGraph();
    }

    private changeTime(from: number, to: number) {
        if (to - from &lt; this.config.time.zoomLimit) {
            to &#x3D; from + this.config.time.zoomLimit;
        }
        this.onTimespanChanged.emit(new Timespan(from, to));
    }

    private isContentLoadingD3(loading: boolean): void {
        this.onContentLoading.emit(loading);
    }

    private loadAddedDataset(dataset: IDataset) {
        this.datasetMap.set(dataset.internalId, dataset);
        this.loadDatasetData(dataset, false);
    }

    // load data of dataset
    private loadDatasetData(dataset: IDataset, force: boolean) {
        const datasetOptions &#x3D; this.datasetOptions.get(dataset.internalId);
        if (this.loadingCounter &#x3D;&#x3D;&#x3D; 0) {
            this.isContentLoadingD3(true);
        }
        this.loadingCounter++;

        if (dataset instanceof Timeseries) {
            const buffer &#x3D; this.timeSrvc.getBufferedTimespan(this.timespan, 0.2);

            this.api.getTsData&lt;[number, number]&gt;(dataset.id, dataset.url, buffer,
                {
                    format: &#x27;flot&#x27;,
                    expanded: this.plotOptions.showReferenceValues &#x3D;&#x3D;&#x3D; true,
                    generalize: this.plotOptions.generalizeAllways || datasetOptions.generalize
                },
                { forceUpdate: force }
            ).subscribe(
                (result) &#x3D;&gt; {
                    this.datasetMap.get(dataset.internalId).data &#x3D; result;
                    this.prepareTsData(dataset).subscribe(() &#x3D;&gt; {
                    });
                },
                (error) &#x3D;&gt; this.onError(error),
                () &#x3D;&gt; {
                    this.onCompleteLoadingData();
                }
            );
        }
    }

    private onCompleteLoadingData() {
        this.loadingCounter--;
        if (this.loadingCounter &#x3D;&#x3D;&#x3D; 0) { this.isContentLoadingD3(false); }
    }

    /**
     * Function to prepare each dataset for the graph and adding it to an array of datasets.
     * @param dataset {IDataset} Object of the whole dataset
     */
    private prepareTsData(dataset: IDataset): Observable&lt;boolean&gt; { // , data: Data&lt;[number, number]&gt;
        return Observable.create((observer: Observer&lt;boolean&gt;) &#x3D;&gt; {
            const datasetIdx &#x3D; this.preparedData.findIndex((e) &#x3D;&gt; e.internalId &#x3D;&#x3D;&#x3D; dataset.internalId);
            const styles &#x3D; this.datasetOptions.get(dataset.internalId);
            const data &#x3D; this.datasetMap.get(dataset.internalId).data;

            // TODO: change uom for testing
            // if (this.preparedData.length &gt; 0) {
            //     dataset.uom &#x3D; &#x27;mc&#x27;;
            // }

            // generate random color, if color is not defined
            if (styles.color &#x3D;&#x3D;&#x3D; undefined) {
                styles.color &#x3D; this.colorService.getColor();
            }

            // end of check for datasets
            const dataEntry: InternalDataEntry &#x3D; {
                internalId: dataset.internalId,
                color: styles.color,
                data: styles.visible ? data.values : [],
                points: {
                    fillColor: styles.color
                },
                lines: {
                    lineWidth: styles.lineWidth,
                    pointRadius: styles.pointRadius
                },
                bars: {
                    lineWidth: styles.lineWidth
                },
                axisOptions: {
                    uom: dataset.uom,
                    label: dataset.label,
                    zeroBased: styles.zeroBasedYAxis,
                    yAxisRange: styles.yAxisRange,
                    autoRangeSelection: styles.autoRangeSelection,
                    separateYAxis: styles.separateYAxis
                },
                visible: styles.visible
            };

            let separationIdx &#x3D; this.listOfSeparation.findIndex((id) &#x3D;&gt; id &#x3D;&#x3D;&#x3D; dataset.internalId);
            if (styles.separateYAxis) {
                if (separationIdx &lt; 0) {
                    this.listOfSeparation.push(dataset.internalId);
                }
            } else {
                this.listOfSeparation &#x3D; this.listOfSeparation.filter(entry &#x3D;&gt; entry !&#x3D;&#x3D; dataset.internalId);
            }

            // alternative linewWidth &#x3D; this.plotOptions.selected.includes(dataset.uom)
            if (this.selectedDatasetIds.indexOf(dataset.internalId) &gt;&#x3D; 0) {
                dataEntry.lines.lineWidth +&#x3D; this.addLineWidth;
                dataEntry.lines.pointRadius +&#x3D; this.addLineWidth;
                dataEntry.bars.lineWidth +&#x3D; this.addLineWidth;

                if (styles.separateYAxis) {
                    this.checkYselector(dataEntry.internalId, dataEntry.axisOptions.uom);
                    if (this.yAxisSelect[dataEntry.internalId]) {
                        this.yAxisSelect[dataEntry.internalId].clicked &#x3D; true;
                        this.yAxisSelect[dataEntry.internalId].ids.push(dataEntry.internalId);
                    }
                }
            }

            if (datasetIdx &gt;&#x3D; 0) {
                this.preparedData[datasetIdx] &#x3D; dataEntry;
            } else {
                this.preparedData.push(dataEntry);
            }
            this.addReferenceValueData(dataset.internalId, styles, data, dataset.uom);
            this.processData(dataEntry);
        });
    }

    /**
     * Function to add referencevaluedata to the dataset (e.g. mean).
     * @param internalId {String} String with the id of a dataset
     * @param styles {DatasetOptions} Object containing information for dataset styling
     * @param data {Data} Array of Arrays containing the measurement-data of the dataset
     * @param uomO {String} String with the uom of a dataset
     */
    private addReferenceValueData(internalId: string, styles: DatasetOptions, data: Data&lt;[number, number]&gt;, uomO: string) {
        this.preparedData &#x3D; this.preparedData.filter((entry) &#x3D;&gt; {
            return !entry.internalId.startsWith(&#x27;ref&#x27; + internalId);
        });
        if (this.plotOptions.showReferenceValues) {
            styles.showReferenceValues.forEach((refValue) &#x3D;&gt; {
                const refDataEntry &#x3D; {
                    internalId: &#x27;ref&#x27; + internalId + refValue.id,
                    color: refValue.color,
                    data: data.referenceValues[refValue.id],
                    points: {
                        fillColor: refValue.color
                    },
                    lines: {
                        lineWidth: 1
                    },
                    axisOptions: {
                        uom: uomO
                    }
                };
                this.preparedData.push(refDataEntry);
            });
        }
    }

    /**
     * Function that processes the data to calculate y axis range of each dataset.
     * @param dataEntry {DataEntry} Object containing dataset related data.
     * @param internalId {String} String with the ID of a dataset.
     */
    protected processData(dataEntry: InternalDataEntry) {
        let calculatedRange: MinMaxRange;
        let calculatedPreRange: MinMaxRange;
        let calculatedOriginRange: MinMaxRange;
        let predefinedRange &#x3D; dataEntry.axisOptions.yAxisRange;
        let autoDataExtent &#x3D; dataEntry.axisOptions.autoRangeSelection;

        // get min and max value of data
        const dataExtent &#x3D; d3.extent&lt;[number, number], number&gt;(dataEntry.data, (datum, index, array) &#x3D;&gt; {
            return datum[1]; // datum[0] &#x3D; timestamp -- datum[1] &#x3D; value
        });

        calculatedOriginRange &#x3D; { min: dataExtent[0], max: dataExtent[1] };

        // let outOfrange &#x3D; false;
        let setDataExtent &#x3D; false;

        // calculate out of predefined range
        if (predefinedRange &amp;&amp; !this.graphOptions.overview) {
            if (predefinedRange.min &gt; predefinedRange.max) {
                calculatedRange &#x3D; { min: predefinedRange.max, max: predefinedRange.min };
                calculatedPreRange &#x3D; { min: predefinedRange.max, max: predefinedRange.min };
            } else {
                calculatedRange &#x3D; { min: predefinedRange.min, max: predefinedRange.max };
                calculatedPreRange &#x3D; { min: predefinedRange.min, max: predefinedRange.max };
            }
            if (predefinedRange.min &gt; dataExtent[1] || predefinedRange.max &lt; dataExtent[0]) {
                setDataExtent &#x3D; autoDataExtent ? false : true;
            }
        } else {
            setDataExtent &#x3D; true;
        }

        if (setDataExtent) {
            calculatedRange &#x3D; { min: dataExtent[0], max: dataExtent[1] };
            if (calculatedRange.min &#x3D;&#x3D;&#x3D; calculatedRange.max) {
                calculatedRange.min &#x3D; calculatedRange.min - (calculatedRange.min * 0.1);
                calculatedRange.max &#x3D; calculatedRange.max + (calculatedRange.max * 0.1);
            }
        }

        // if style option &#x27;zero based y-axis&#x27; is checked,
        // the axis will be aligned to top 0 (with data below 0) or to bottom 0 (with data above 0)
        // let zeroBasedValue &#x3D; -1;
        if (dataEntry.axisOptions.zeroBased &amp;&amp; !this.graphOptions.overview) {
            if (dataExtent[1] &lt;&#x3D; 0) {
                calculatedRange.max &#x3D; 0;
                calculatedPreRange.max &#x3D; 0;
            }
            if (dataExtent[0] &gt;&#x3D; 0) {
                calculatedRange.min &#x3D; 0;
                calculatedPreRange.min &#x3D; 0;
            }
        }

        const newDatasetIdx &#x3D; this.preparedData.findIndex((e) &#x3D;&gt; e.internalId &#x3D;&#x3D;&#x3D; dataEntry.internalId);

        // set range, uom and id for each dataset
        if (dataEntry.visible) {
            this.dataYranges[newDatasetIdx] &#x3D; {
                uom: dataEntry.axisOptions.uom,
                id: dataEntry.internalId,
                zeroBasedYAxis: dataEntry.axisOptions.zeroBased,
                outOfrange: setDataExtent,
                autoRange: autoDataExtent
            };
            if (isFinite(calculatedRange.min) &amp;&amp; isFinite(calculatedRange.max)) {
                this.dataYranges[newDatasetIdx].range &#x3D; calculatedRange;
                this.dataYranges[newDatasetIdx].preRange &#x3D; calculatedPreRange;
                this.dataYranges[newDatasetIdx].originRange &#x3D; calculatedOriginRange;
            }
        } else {
            this.dataYranges[newDatasetIdx] &#x3D; null;
        }

        // set range and array of IDs for each uom to generate y-axis later on
        this.yRangesEachUom &#x3D; [];
        this.dataYranges.forEach((obj) &#x3D;&gt; {
            if (obj !&#x3D;&#x3D; null) {
                let idx &#x3D; this.yRangesEachUom.findIndex((e) &#x3D;&gt; e.uom &#x3D;&#x3D;&#x3D; obj.uom);
                let yrangeObj: YRanges &#x3D; {
                    uom: obj.uom,
                    range: obj.range,
                    preRange: obj.preRange,
                    originRange: obj.originRange,
                    ids: [obj.id],
                    zeroBased: obj.zeroBasedYAxis,
                    outOfrange: obj.outOfrange,
                    autoRange: obj.autoRange
                };

                if (idx &gt;&#x3D; 0) {
                    if (this.yRangesEachUom[idx].range) {
                        if (obj.range) {
                            if (this.yRangesEachUom[idx].autoRange || obj.autoRange) {
                                if (obj.preRange &amp;&amp; this.yRangesEachUom[idx].preRange) {
                                    this.checkCurrentLatest(idx, obj, &#x27;preRange&#x27;);
                                    this.yRangesEachUom[idx].range &#x3D; this.yRangesEachUom[idx].preRange;
                                } else {
                                    this.checkCurrentLatest(idx, obj, &#x27;range&#x27;);
                                }
                                this.yRangesEachUom[idx].autoRange &#x3D; true;
                            } else {
                                if (obj.outOfrange !&#x3D;&#x3D; this.yRangesEachUom[idx].outOfrange) {
                                    this.checkCurrentLatest(idx, obj, &#x27;originRange&#x27;);
                                    this.yRangesEachUom[idx].range &#x3D; this.yRangesEachUom[idx].originRange;
                                } else {
                                    this.checkCurrentLatest(idx, obj, &#x27;range&#x27;);
                                }
                            }
                        }
                    } else {
                        this.takeLatest(idx, obj, &#x27;range&#x27;);
                    }

                    this.yRangesEachUom[idx].ids.push(obj.id);

                } else {
                    this.yRangesEachUom.push(yrangeObj);
                }
            }
        });
        this.plotGraph();
    }

    private checkCurrentLatest(idx, obj, pos) {
        if (this.yRangesEachUom[idx][pos].min &gt; obj[pos].min &amp;&amp; !isNaN(obj[pos].min)) {
            this.yRangesEachUom[idx][pos].min &#x3D; obj[pos].min;
        }
        if (this.yRangesEachUom[idx][pos].max &lt; obj[pos].max &amp;&amp; !isNaN(obj[pos].max)) {
            this.yRangesEachUom[idx][pos].max &#x3D; obj[pos].max;
        }
    }

    private takeLatest(idx, obj, pos) {
        this.yRangesEachUom[idx][pos] &#x3D; obj[pos];
    }

    /**
     * Function that returns the height of the graph diagram.
     */
    private calculateHeight(): number {
        return this.rawSvg.node().height.baseVal.value - this.margin.top - this.margin.bottom;
    }

    /**
     * Function that returns the width of the graph diagram.
     */
    private calculateWidth(): number {
        return this.rawSvg.node().width.baseVal.value - this.margin.left - this.margin.right - this.maxLabelwidth;
    }

    /**
     * Function that returns the value range for building the y axis for each uom of every dataset.
     * @param uom {String} String that is the uom of a dataset
     */
    private getyAxisRange(uom) {

        for (let i &#x3D; 0; i &lt;&#x3D; this.yRangesEachUom.length; i++) {
            if (this.yRangesEachUom[i].uom &#x3D;&#x3D;&#x3D; uom) {
                let range &#x3D; this.yRangesEachUom[i].range;

                // check for zero based y axis
                // if (this.yRangesEachUom[i].zeroBased) {
                //     if (this.yRangesEachUom[i].zeroBasedValue &#x3D;&#x3D;&#x3D; 0) {
                //         range.min &#x3D; 0;
                //     } else {
                //         range.max &#x3D; 0;
                //     }
                // }

                return range;
            }
        }

        return null; // error: uom does not exist
    }

    /**
     * Function to plot the graph and its dependencies
     * (graph line, graph axes, event handlers)
     */
    protected plotGraph() {
        if (!this.yRangesEachUom) { return; }

        this.preparedData.forEach((entry) &#x3D;&gt; {
            let idx &#x3D; this.listOfUoms.findIndex((uom) &#x3D;&gt; uom &#x3D;&#x3D;&#x3D; entry.axisOptions.uom);
            if (idx &lt; 0) { this.listOfUoms.push(entry.axisOptions.uom); }
        });

        // adapt axis highlighting, when changing grouping of y axis
        if (this.oldGroupYaxis !&#x3D;&#x3D; this.plotOptions.groupYaxis) {
            this.changeYselection();
        }

        this.height &#x3D; this.calculateHeight();
        this.width &#x3D; this.calculateWidth();
        this.graph.selectAll(&#x27;*&#x27;).remove();

        this.bufferSum &#x3D; 0;
        this.yScaleBase &#x3D; null;

        // get range of x and y axis
        this.xAxisRange &#x3D; this.timespan;

        // #####################################################
        let rangeArray &#x3D; [];
        if (this.plotOptions.groupYaxis || this.plotOptions.groupYaxis &#x3D;&#x3D;&#x3D; undefined) {
            rangeArray &#x3D; this.yRangesEachUom;
            // push all listOfSeparation into rangeArray
            if (this.listOfSeparation.length &gt; 0) {
                this.listOfSeparation.forEach((sepId) &#x3D;&gt; {
                    let newEl &#x3D; this.dataYranges.find((el) &#x3D;&gt; el.id &#x3D;&#x3D;&#x3D; sepId);
                    if (newEl &amp;&amp; (rangeArray.findIndex(el &#x3D;&gt; el.id &#x3D;&#x3D;&#x3D; newEl.id) &lt; 0)) {
                        rangeArray.push(newEl);
                    }
                });
            }

        } else {
            rangeArray &#x3D; this.dataYranges;
        }

        rangeArray.forEach((entry) &#x3D;&gt; {
            entry.first &#x3D; (this.yScaleBase &#x3D;&#x3D;&#x3D; null);
            entry.offset &#x3D; this.bufferSum;

            let yAxisResult &#x3D; this.drawYaxis(entry);
            if (this.yScaleBase &#x3D;&#x3D;&#x3D; null) {
                this.yScaleBase &#x3D; yAxisResult.yScale;
                this.bufferSum &#x3D; yAxisResult.buffer;
            } else {
                this.bufferSum &#x3D; yAxisResult.buffer;
            }
            entry.yScale &#x3D; yAxisResult.yScale;
        });

        if (!this.yScaleBase) {
            return;
        }

        // draw x and y axis
        this.drawXaxis(this.bufferSum);
        this.drawAllGraphLines();

        // #####################################################
        // create background rect
        if (!this.plotOptions.overview) {
            // execute when it is not an overview diagram
            this.background &#x3D; this.graph.append(&#x27;svg:rect&#x27;)
                .attr(&#x27;width&#x27;, this.width - this.bufferSum)
                .attr(&#x27;height&#x27;, this.height)
                .attr(&#x27;fill&#x27;, &#x27;none&#x27;)
                .attr(&#x27;stroke&#x27;, &#x27;none&#x27;)
                .attr(&#x27;pointer-events&#x27;, &#x27;all&#x27;)
                .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + this.bufferSum + &#x27;, 0)&#x27;);

            // mouse events hovering
            if (this.plotOptions.hoverable) {
                this.background
                    .on(&#x27;mousemove.focus&#x27;, this.mousemoveHandler)
                    .on(&#x27;mouseout.focus&#x27;, this.mouseoutHandler);

                // line inside graph
                this.focusG &#x3D; this.graph.append(&#x27;g&#x27;);
                this.highlightFocus &#x3D; this.focusG.append(&#x27;svg:line&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;mouse-focus-line&#x27;)
                    .attr(&#x27;x2&#x27;, &#x27;0&#x27;)
                    .attr(&#x27;y2&#x27;, &#x27;0&#x27;)
                    .attr(&#x27;x1&#x27;, &#x27;0&#x27;)
                    .attr(&#x27;y1&#x27;, &#x27;0&#x27;)
                    .style(&#x27;stroke&#x27;, &#x27;black&#x27;)
                    .style(&#x27;stroke-width&#x27;, &#x27;1px&#x27;);

                this.preparedData.forEach((entry) &#x3D;&gt; {
                    // label inside graph
                    entry.focusLabelRect &#x3D; this.focusG.append(&#x27;svg:rect&#x27;)
                        .attr(&#x27;class&#x27;, &#x27;mouse-focus-label&#x27;)
                        .style(&#x27;fill&#x27;, &#x27;white&#x27;)
                        .style(&#x27;stroke&#x27;, &#x27;none&#x27;)
                        .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;);
                    entry.focusLabel &#x3D; this.focusG.append(&#x27;svg:text&#x27;)
                        .attr(&#x27;class&#x27;, &#x27;mouse-focus-label&#x27;)
                        .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
                        .style(&#x27;fill&#x27;, entry.color)
                        .style(&#x27;font-weight&#x27;, &#x27;lighter&#x27;);

                    this.focuslabelTime &#x3D; this.focusG.append(&#x27;svg:text&#x27;)
                        .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
                        .attr(&#x27;class&#x27;, &#x27;mouse-focus-time&#x27;);
                });
            }

            if (this.plotOptions.togglePanZoom &#x3D;&#x3D;&#x3D; false) {
                this.background
                    .call(d3.zoom()
                        .on(&#x27;start&#x27;, this.zoomStartHandler)
                        .on(&#x27;zoom&#x27;, this.zoomHandler)
                        .on(&#x27;end&#x27;, this.zoomEndHandler)
                    );
            } else {
                this.background
                    .call(d3.drag()
                        .on(&#x27;start&#x27;, this.panStartHandler)
                        .on(&#x27;drag&#x27;, this.panMoveHandler)
                        .on(&#x27;end&#x27;, this.panEndHandler));
            }

            this.createCopyrightLabel();
        } else {
            // execute when it is overview diagram
            let interval &#x3D; this.getXDomainByTimestamp();
            let overviewTimespanInterval &#x3D; [interval[0], interval[1]];

            // create brush
            let brush &#x3D; d3.brushX()
                .extent([[0, 0], [this.width, this.height]])
                .on(&#x27;end&#x27;, () &#x3D;&gt; {
                    // on mouseclick change time after brush was moved
                    if (this.mousedownBrush) {
                        let timeByCoord &#x3D; this.getTimestampByCoord(d3.event.selection[0], d3.event.selection[1]);
                        this.changeTime(timeByCoord[0], timeByCoord[1]);
                    }
                    this.mousedownBrush &#x3D; false;
                });

            // add brush to svg
            this.background &#x3D; this.graph.append(&#x27;g&#x27;)
                .attr(&#x27;width&#x27;, this.width)
                .attr(&#x27;height&#x27;, this.height)
                .attr(&#x27;pointer-events&#x27;, &#x27;all&#x27;)
                .attr(&#x27;class&#x27;, &#x27;brush&#x27;)
                .call(brush)
                .call(brush.move, overviewTimespanInterval);

            /**
             * add event to selection to prevent unnecessary re-rendering of brush
             * add style of brush selection here
             * e.g. &#x27;fill&#x27; for color,
             * &#x27;stroke&#x27; for borderline-color,
             * &#x27;stroke-dasharray&#x27; for customizing borderline-style
             */
            this.background.selectAll(&#x27;.selection&#x27;)
                .attr(&#x27;stroke&#x27;, &#x27;none&#x27;)
                .on(&#x27;mousedown&#x27;, () &#x3D;&gt; {
                    this.mousedownBrush &#x3D; true;
                });

            // do not allow clear selection
            this.background.selectAll(&#x27;.overlay&#x27;)
                .remove();

            // add event to resizing handle to allow change time on resize
            this.background.selectAll(&#x27;.handle&#x27;)
                .style(&#x27;fill&#x27;, &#x27;red&#x27;)
                .style(&#x27;opacity&#x27;, 0.3)
                .attr(&#x27;stroke&#x27;, &#x27;none&#x27;)
                .on(&#x27;mousedown&#x27;, () &#x3D;&gt; {
                    this.mousedownBrush &#x3D; true;
                });
        }
    }

    private createCopyrightLabel() {
        if (this.plotOptions.copyright) {
            let background &#x3D; this.getDimensions(this.background.node());
            // default &#x3D; top left
            let x &#x3D; 0; // left
            let y &#x3D; 0; // + this.margin.top; // top
            this.copyright &#x3D; this.graph.append(&#x27;g&#x27;);
            let copyrightLabel &#x3D; this.copyright.append(&#x27;svg:text&#x27;)
                .text(this.plotOptions.copyright.label)
                .attr(&#x27;class&#x27;, &#x27;copyright&#x27;)
                .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
                .style(&#x27;fill&#x27;, &#x27;grey&#x27;);
            if (this.plotOptions.copyright.positionX &#x3D;&#x3D;&#x3D; &#x27;right&#x27;) {
                x &#x3D; background.w - this.margin.right - this.getDimensions(copyrightLabel.node()).w;
            }
            if (this.plotOptions.copyright.positionY &#x3D;&#x3D;&#x3D; &#x27;bottom&#x27;) {
                y &#x3D; background.h - this.margin.top * 2;
            }
            let yTransform &#x3D; y + this.getDimensions(copyrightLabel.node()).h - 3;
            let xTransform &#x3D; this.bufferSum + x;
            copyrightLabel
                .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + xTransform + &#x27;, &#x27; + yTransform + &#x27;)&#x27;);
            this.copyright.append(&#x27;svg:rect&#x27;)
                .attr(&#x27;class&#x27;, &#x27;copyright&#x27;)
                .style(&#x27;fill&#x27;, &#x27;none&#x27;)
                .style(&#x27;stroke&#x27;, &#x27;none&#x27;)
                .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;)
                .attr(&#x27;width&#x27;, this.getDimensions(copyrightLabel.node()).w)
                .attr(&#x27;height&#x27;, this.getDimensions(copyrightLabel.node()).h)
                .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + xTransform + &#x27;, &#x27; + y + &#x27;)&#x27;);
        }
    }

    /**
     * Draws for every preprared data entry the graph line.
     */
    protected drawAllGraphLines() {
        this.preparedData.forEach((entry) &#x3D;&gt; this.drawGraphLine(entry));
    }

    /**
     * Function that calculates and returns the x diagram coordinate for the brush range
     * for the overview diagram by the selected time interval of the main diagram.
     * Calculate to get brush extent when main diagram time interval changes.
     */
    private getXDomainByTimestamp() {
        /**
         * calculate range of brush with timestamp and not diagram coordinates
         * formula:
         * brush_min &#x3D;
         * (overview_width / (overview_max - overview_min)) * (brush_min - overview_min)
         * brus_max &#x3D;
         * (overview_width / (overview_max - overview_min)) * (brush_max - overview_min)
         */

        let minOverviewTimeInterval &#x3D; this.timespan.from;
        let maxOverviewTimeInterval &#x3D; this.timespan.to;
        let minDiagramTimestamp &#x3D; this.mainTimeInterval.from;
        let maxDiagramTimestamp &#x3D; this.mainTimeInterval.to;
        let diagramWidth &#x3D; this.width;

        let diffOverviewTimeInterval &#x3D; maxOverviewTimeInterval - minOverviewTimeInterval;
        let divOverviewTimeWidth &#x3D; diagramWidth / diffOverviewTimeInterval;
        let minCalcBrush &#x3D; divOverviewTimeWidth * (minDiagramTimestamp - minOverviewTimeInterval);
        let maxCalcBrush &#x3D; divOverviewTimeWidth * (maxDiagramTimestamp - minOverviewTimeInterval);

        return [minCalcBrush, maxCalcBrush];
    }

    /**
     * Function that calculates and returns the timestamp for the main diagram calculated
     * by the selected coordinate of the brush range.
     * @param minCalcBrush {Number} Number with the minimum coordinate of the selected brush range.
     * @param maxCalcBrush {Number} Number with the maximum coordinate of the selected brush range.
     */
    private getTimestampByCoord(minCalcBrush, maxCalcBrush) {
        /**
         * calculate range of brush with timestamp and not diagram coordinates
         * formula:
         * minDiagramTimestamp &#x3D;
         * ((minCalcBrush / overview_width) * (overview_max - overview_min)) + overview_min
         * maxDiagramTimestamp &#x3D;
         * ((maxCalcBrush / overview_width) * (overview_max - overview_min)) + overview_min
         */

        let minOverviewTimeInterval &#x3D; this.timespan.from;
        let maxOverviewTimeInterval &#x3D; this.timespan.to;
        let diagramWidth &#x3D; this.width;

        let diffOverviewTimeInterval &#x3D; maxOverviewTimeInterval - minOverviewTimeInterval;
        let minDiagramTimestamp &#x3D; ((minCalcBrush / diagramWidth) * diffOverviewTimeInterval) + minOverviewTimeInterval;
        let maxDiagramTimestamp &#x3D; ((maxCalcBrush / diagramWidth) * diffOverviewTimeInterval) + minOverviewTimeInterval;

        return [minDiagramTimestamp, maxDiagramTimestamp];
    }

    /**
     * Function that returns the tickvalues for the x axis related to the timestep.
     * @param time {String} String with the information how the time should be visualized in the x axis.
     * @param range {Array} Array containing the minimum and maximum range.
     * @param span {Number} Number with the ticksize for the axis generation.
     */
    private timeTickValues(time: String, range: any, span: number) {
        if (time &#x3D;&#x3D;&#x3D; &#x27;minly&#x27;) {
            return d3.timeMinutes(range, new Date(this.xAxisRange.to), span);
        }
        if (time &#x3D;&#x3D;&#x3D; &#x27;hourly&#x27;) {
            return d3.timeHours(range, new Date(this.xAxisRange.to), span);
        }
        if (time &#x3D;&#x3D;&#x3D; &#x27;daily&#x27;) {
            return d3.timeDay.range(range, new Date(this.xAxisRange.to), span);
        }
    }

    /**
     * Function that draws the x axis to the svg element.
     * @param bufferXrange {Number} Number with the distance between left edge and the beginning of the graph.
     */
    private drawXaxis(bufferXrange: number) {
        // range for x axis scale
        this.xScaleBase &#x3D; d3.scaleTime()
            .domain([this.xAxisRange.from, this.xAxisRange.to])
            .range([bufferXrange, this.width]);

        let xAxis &#x3D; d3.axisBottom(this.xScaleBase)
            .tickFormat(d &#x3D;&gt; {
                const date &#x3D; new Date(d.valueOf());

                const formatMillisecond &#x3D; &#x27;.%L&#x27;,
                    formatSecond &#x3D; &#x27;:%S&#x27;,
                    formatMinute &#x3D; &#x27;%H:%M&#x27;,
                    formatHour &#x3D; &#x27;%H:%M&#x27;,
                    formatDay &#x3D; &#x27;%a %d&#x27;,
                    formatWeek &#x3D; &#x27;%b %d&#x27;,
                    formatMonth &#x3D; &#x27;%B&#x27;,
                    formatYear &#x3D; &#x27;%Y&#x27;;

                const format &#x3D; d3.timeSecond(date) &lt; date ? formatMillisecond
                    : d3.timeMinute(date) &lt; date ? formatSecond
                        : d3.timeHour(date) &lt; date ? formatMinute
                            : d3.timeDay(date) &lt; date ? formatHour
                                : d3.timeMonth(date) &lt; date ? (d3.timeWeek(date) &lt; date ? formatDay : formatWeek)
                                    : d3.timeYear(date) &lt; date ? formatMonth
                                        : formatYear;
                return this.timeFormatLocaleService.getTimeLocale(format)(new Date(d.valueOf()));
            });

        this.graph.append(&#x27;g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;x axis&#x27;)
            .attr(&#x27;transform&#x27;, &#x27;translate(0,&#x27; + this.height + &#x27;)&#x27;)
            .call(xAxis)
            .selectAll(&#x27;text&#x27;)
            .style(&#x27;text-anchor&#x27;, &#x27;middle&#x27;);

        if (this.plotOptions.grid) {
            // draw the x grid lines
            this.graph.append(&#x27;svg:g&#x27;)
                .attr(&#x27;class&#x27;, &#x27;grid&#x27;)
                .attr(&#x27;transform&#x27;, &#x27;translate(0,&#x27; + this.height + &#x27;)&#x27;)
                .call(xAxis
                    .tickSize(-this.height)
                    .tickFormat(() &#x3D;&gt; &#x27;&#x27;)
                );
        }

        // draw upper axis as border
        this.graph.append(&#x27;svg:g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;x axis&#x27;)
            .call(d3.axisTop(this.xScaleBase).ticks(0).tickSize(0));

        // text label for the x axis
        this.graph.append(&#x27;text&#x27;)
            .attr(&#x27;x&#x27;, (this.width + bufferXrange) / 2)
            .attr(&#x27;y&#x27;, this.height + this.margin.bottom - 5)
            .style(&#x27;text-anchor&#x27;, &#x27;middle&#x27;)
            .text(&#x27;time&#x27;);
    }

    /**
     * Function to draw the y axis for each dataset.
     * Each uom has its own axis.
     * @param entry {DataEntry} Object containing a dataset.
     */
    private drawYaxis(entry): YScale {
        let showAxis &#x3D; (this.plotOptions.overview ? false : (this.plotOptions.yaxis &#x3D;&#x3D;&#x3D; undefined ? true : this.plotOptions.yaxis));
        // check for y axis grouping
        let range;
        if (this.plotOptions.groupYaxis || this.plotOptions.groupYaxis &#x3D;&#x3D;&#x3D; undefined) {
            let uomIdx &#x3D; this.listOfUoms.findIndex((uom) &#x3D;&gt; uom &#x3D;&#x3D;&#x3D; entry.uom);
            if (uomIdx &gt;&#x3D; 0) {
                range &#x3D; this.getyAxisRange(entry.uom);
            } else {
                // if not entry.uom but separated id
                let entryElem &#x3D; this.dataYranges.find((el) &#x3D;&gt; el.id &#x3D;&#x3D;&#x3D; entry.id);
                range &#x3D; entryElem.range;
            }

        } else {
            let entryElem &#x3D; this.dataYranges.find((el) &#x3D;&gt; el.id &#x3D;&#x3D;&#x3D; entry.id);
            range &#x3D; entryElem.range;
        }

        let yMin &#x3D; -1;
        let yMax &#x3D; 1;

        if (range !&#x3D;&#x3D; undefined &amp;&amp; range !&#x3D;&#x3D; null) {
            yMin &#x3D; range.min;
            yMax &#x3D; range.max;
        }

        // range for y axis scale
        const rangeOffset &#x3D; (yMax - yMin) * 0.10;
        const yScale &#x3D; d3.scaleLinear()
            .domain([yMin - rangeOffset, yMax + rangeOffset])
            .range([this.height, 0]);

        let yAxisGen &#x3D; d3.axisLeft(yScale).ticks(5);
        let buffer &#x3D; 0;

        // only if yAxis should not be visible
        if (!showAxis) {
            yAxisGen
                .tickFormat(() &#x3D;&gt; &#x27;&#x27;)
                .tickSize(0);
        }

        // draw y axis
        const axis &#x3D; this.graph.append(&#x27;svg:g&#x27;)
            .attr(&#x27;class&#x27;, &#x27;y axis&#x27;)
            .call(yAxisGen);

        // only if yAxis should be visible
        if (showAxis) {
            // draw y axis label
            const text &#x3D; this.graph.append(&#x27;text&#x27;)
                .attr(&#x27;transform&#x27;, &#x27;rotate(-90)&#x27;)
                .attr(&#x27;dy&#x27;, &#x27;1em&#x27;)
                .style(&#x27;font&#x27;, &#x27;18px times&#x27;)
                .style(&#x27;text-anchor&#x27;, &#x27;middle&#x27;)
                .style(&#x27;fill&#x27;, &#x27;black&#x27;)
                .text((entry.id ? (entry.uom + &#x27; (&#x27; + entry.id + &#x27;)&#x27;) : entry.uom));

            const axisWidth &#x3D; axis.node().getBBox().width + 10 + this.getDimensions(text.node()).h;
            // if yAxis should not be visible, buffer will be set to 0
            buffer &#x3D; (showAxis ? entry.offset + (axisWidth &lt; this.margin.left ? this.margin.left : axisWidth) : 0);
            const axisWidthDiv &#x3D; (axisWidth &lt; this.margin.left ? this.margin.left : axisWidth);

            if (!entry.first) {
                axis.attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + buffer + &#x27;, 0)&#x27;);
            } else {
                buffer &#x3D; axisWidthDiv - this.margin.left;
                axis.attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + buffer + &#x27;, 0)&#x27;);
            }

            let textOff &#x3D; - (this.bufferSum);
            if (entry.first) {
                textOff &#x3D; this.margin.left;
            }
            text.attr(&#x27;y&#x27;, 0 - textOff)
                .attr(&#x27;x&#x27;, 0 - (this.height / 2));

            // set id to uom, if group yaxis is toggled, else set id to dataset id
            let id: string &#x3D; (entry.id ? entry.id : entry.uom);
            this.checkYselector(id, entry.uom);

            const axisDiv &#x3D; this.graph.append(&#x27;rect&#x27;)
                // .attr(&#x27;id&#x27;, &#x27;yaxis&#x27; + id)
                .attr(&#x27;class&#x27;, &#x27;axisDiv&#x27;)
                .attr(&#x27;width&#x27;, axisWidthDiv)
                .attr(&#x27;height&#x27;, this.height)
                .attr(&#x27;fill&#x27;, &#x27;grey&#x27;)
                .attr(&#x27;opacity&#x27;, (this.yAxisSelect[id].clicked ? this.opac.click : this.opac.default))
                .on(&#x27;mouseover&#x27;, (d, i, k) &#x3D;&gt; {
                    d3.select(k[0])
                        .attr(&#x27;opacity&#x27;, this.opac.hover);
                })
                .on(&#x27;mouseout&#x27;, (d, i, k) &#x3D;&gt; {
                    if (!this.yAxisSelect[id].clicked) {
                        d3.select(k[0])
                            .attr(&#x27;opacity&#x27;, this.opac.default);
                    } else {
                        d3.select(k[0])
                            .attr(&#x27;opacity&#x27;, this.opac.click);
                    }
                })
                .on(&#x27;mouseup&#x27;, (d, i, k) &#x3D;&gt; {
                    if (!this.yAxisSelect[id].clicked) {
                        d3.select(k[0])
                            .attr(&#x27;opacity&#x27;, this.opac.default);
                    } else {
                        d3.select(k[0])
                            .attr(&#x27;opacity&#x27;, this.opac.click);
                    }
                    this.yAxisSelect[id].clicked &#x3D; !this.yAxisSelect[id].clicked;

                    let entryArray &#x3D; [];
                    if (entry.id) {
                        entryArray.push(entry.id);
                    } else {
                        entryArray &#x3D; entry.ids;
                    }
                    this.highlightLine(entryArray);
                });

            if (!entry.first) {
                axisDiv
                    .attr(&#x27;x&#x27;, entry.offset)
                    .attr(&#x27;y&#x27;, 0);
            } else {
                axisDiv
                    .attr(&#x27;x&#x27;, 0 - this.margin.left - this.maxLabelwidth)
                    .attr(&#x27;y&#x27;, 0);
            }

        }

        // draw the y grid lines
        if (this.datasetIds.length &#x3D;&#x3D;&#x3D; 1) {
            this.graph.append(&#x27;svg:g&#x27;)
                .attr(&#x27;class&#x27;, &#x27;grid&#x27;)
                .call(d3.axisLeft(yScale)
                    .ticks(5)
                    .tickSize(-this.width)
                    .tickFormat(() &#x3D;&gt; &#x27;&#x27;)
                );
        }

        return {
            buffer,
            yScale
        };
    }

    /**
     * Function to check whether object yAxisSelect exists with selected uom.
     * If it does not exist, it will be created.
     * @param identifier {String} String providing the selected uom or the selected dataset ID.
     */
    private checkYselector(identifier, uom) {
        if (this.yAxisSelect &#x3D;&#x3D;&#x3D; undefined) {
            this.yAxisSelect &#x3D; {};
        }

        let selector: YAxisSelection &#x3D; {
            id: identifier,
            ids: (this.yAxisSelect[identifier] !&#x3D;&#x3D; undefined ? this.yAxisSelect[identifier].ids : []),
            uom: uom,
            clicked: (this.yAxisSelect[identifier] !&#x3D;&#x3D; undefined ? this.yAxisSelect[identifier].clicked : false)
        };

        this.yAxisSelect[identifier] &#x3D; selector;
    }

    /**
     * Function to adapt y axis highlighting to selected TS or selected uom
     */
    private changeYselection() {
        let groupList &#x3D; {};
        if (this.yAxisSelect) {
            if (!this.plotOptions.groupYaxis) {
                // before: group
                for (let key in this.yAxisSelect) {
                    if (this.yAxisSelect.hasOwnProperty(key)) {
                        let el &#x3D; this.yAxisSelect[key];
                        if (el.clicked) {
                            el.ids.forEach((id) &#x3D;&gt; {
                                let dataEl &#x3D; this.preparedData.find((entry) &#x3D;&gt; entry.internalId &#x3D;&#x3D;&#x3D; id);
                                let newSelector: YAxisSelection &#x3D; {
                                    id: id,
                                    ids: [],
                                    clicked: true,
                                    uom: dataEl.axisOptions.uom
                                };
                                groupList[id] &#x3D; newSelector;
                                groupList[id].ids.push(id);
                            });
                        }
                    }
                }
            } else {
                // before: no group
                for (let key in this.yAxisSelect) {
                    if (this.yAxisSelect.hasOwnProperty(key)) {
                        let el &#x3D; this.yAxisSelect[key];
                        let dataEl &#x3D; this.preparedData.find((entry) &#x3D;&gt; entry.internalId &#x3D;&#x3D;&#x3D; el.id);
                        let selectionID;
                        if (dataEl &amp;&amp; dataEl.axisOptions.separateYAxis) {
                            selectionID &#x3D; dataEl.internalId; // el.uom + &#x27;&#x27; + dataEl.internalId;
                        } else {
                            selectionID &#x3D; dataEl.axisOptions.uom;
                        }
                        if (!groupList[selectionID]) {
                            let currentUom: YAxisSelection &#x3D; {
                                id: selectionID,
                                ids: [],
                                clicked: false,
                                uom: dataEl.axisOptions.uom
                            };
                            groupList[selectionID] &#x3D; currentUom;
                        }

                        if (el.clicked) {
                            groupList[selectionID].ids.push(el.id);
                            groupList[selectionID].clicked &#x3D; true;
                            if (groupList[dataEl.axisOptions.uom]) {
                                groupList[dataEl.axisOptions.uom].ids.push(el.id);
                                groupList[dataEl.axisOptions.uom].clicked &#x3D; true;
                            }
                        }

                        if (groupList[selectionID].id &#x3D;&#x3D;&#x3D; groupList[selectionID].uom) {
                            for (let keyId in groupList) {
                                if (groupList.hasOwnProperty(keyId)) {
                                    if (groupList[keyId].uom &#x3D;&#x3D;&#x3D; groupList[selectionID].id &amp;&amp; groupList[keyId].uom !&#x3D;&#x3D; groupList[selectionID].id) {
                                        if (groupList[keyId].clicked) {
                                            groupList[selectionID].clicked &#x3D; true;
                                            groupList[keyId].ids.push(el.id);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.yAxisSelect &#x3D; {}; // unselect all - y axis
            this.yAxisSelect &#x3D; groupList;
        }
        this.oldGroupYaxis &#x3D; this.plotOptions.groupYaxis;
    }

    /**
     * Function to set selected Ids that should be highlighted.
     * @param ids {Array} Array of Strings containing the Ids.
     * @param uom {String} String with the uom for the selected Ids
     */
    private highlightLine(ids) {
        let changeFalse: HighlightDataset[] &#x3D; [];
        let changeTrue: HighlightDataset[] &#x3D; [];
        ids.forEach((ID) &#x3D;&gt; {
            if (this.selectedDatasetIds.indexOf(ID) &gt;&#x3D; 0) {
                changeFalse.push({ id: ID, change: false });
            }
            changeTrue.push({ id: ID, change: true });
        });

        // let changeAll &#x3D; true;
        if (ids.length &#x3D;&#x3D;&#x3D; changeFalse.length) {
            this.changeSelectedIds(changeFalse, true);
        } else {
            this.changeSelectedIds(changeTrue, false);
        }
    }

    /**
     * Function that changes state of selected Ids.
     */
    private changeSelectedIds(toHighlightDataset: HighlightDataset[], change: boolean) {
        if (change) {
            toHighlightDataset.forEach((obj) &#x3D;&gt; {
                this.removeSelectedId(obj.id);
                this.selectedDatasetIds.splice(this.selectedDatasetIds.findIndex((entry) &#x3D;&gt; entry &#x3D;&#x3D;&#x3D; obj.id), 1);
            });
        } else {
            toHighlightDataset.forEach((obj) &#x3D;&gt; {
                if (this.selectedDatasetIds.indexOf(obj.id) &lt; 0) {
                    this.setSelectedId(obj.id);
                    this.selectedDatasetIds.push(obj.id);
                }
            });
        }

        this.onDatasetSelected.emit(this.selectedDatasetIds);
        this.plotGraph();
    }

    /**
     * Function to draw the graph line for each dataset.
     * @param entry {DataEntry} Object containing a dataset.
     */
    protected drawGraphLine(entry: InternalDataEntry) {
        // const getYaxisRange &#x3D; this.yRangesEachUom.find((obj) &#x3D;&gt; obj.ids.indexOf(entry.internalId) &gt; -1);
        // check for y axis grouping
        let getYaxisRange;
        if (this.plotOptions.groupYaxis || this.plotOptions.groupYaxis &#x3D;&#x3D;&#x3D; undefined) {
            getYaxisRange &#x3D; this.yRangesEachUom.find((obj) &#x3D;&gt; {
                if (obj.uom &#x3D;&#x3D;&#x3D; entry.axisOptions.uom) {
                    return true;
                } // uom does exist in this.yRangesEachUom
            });
        } else {
            getYaxisRange &#x3D; this.dataYranges.find((obj) &#x3D;&gt; {
                if (obj.id &#x3D;&#x3D;&#x3D; entry.internalId) {
                    return true;
                } // id does exist in this.dataYranges
            });
        }

        if (entry.data.length &gt; 0) {
            let xScaleBase &#x3D; this.xScaleBase;
            if (getYaxisRange !&#x3D;&#x3D; undefined) {
                let yScaleBase &#x3D; getYaxisRange.yScale;

                // #####################################################
                // create body to clip graph
                // unique ID generated through the current time (current time when initialized)
                let querySelectorClip &#x3D; &#x27;clip&#x27; + this.currentTimeId;

                this.graph
                    .append(&#x27;svg:clipPath&#x27;)
                    .attr(&#x27;id&#x27;, querySelectorClip)
                    .append(&#x27;svg:rect&#x27;)
                    .attr(&#x27;x&#x27;, this.bufferSum)
                    .attr(&#x27;y&#x27;, 0)
                    .attr(&#x27;width&#x27;, this.width - this.bufferSum)
                    .attr(&#x27;height&#x27;, this.height);

                // draw grah line
                this.graphBody &#x3D; this.graph
                    .append(&#x27;g&#x27;)
                    .attr(&#x27;clip-path&#x27;, &#x27;url(#&#x27; + querySelectorClip + &#x27;)&#x27;);

                // create graph line
                let line &#x3D; d3.line&lt;DataEntry&gt;()
                    .defined((d) &#x3D;&gt; !isNaN(d[1]))
                    .x((d) &#x3D;&gt; {
                        d.timestamp &#x3D; d[0];
                        const xDiagCoord &#x3D; xScaleBase(d[0]);
                        if (!isNaN(xDiagCoord)) {
                            d.xDiagCoord &#x3D; xDiagCoord;
                            return xDiagCoord;
                        }
                    })
                    .y((d) &#x3D;&gt; {
                        const yDiagCoord &#x3D; yScaleBase(d[1]);
                        if (!isNaN(yDiagCoord)) {
                            d.yDiagCoord &#x3D; yDiagCoord;
                            return yDiagCoord;
                        }
                    })
                    .curve(d3.curveLinear);

                this.graphBody
                    .append(&#x27;svg:path&#x27;)
                    .datum(entry.data)
                    .attr(&#x27;class&#x27;, &#x27;line&#x27;)
                    .attr(&#x27;fill&#x27;, &#x27;none&#x27;)
                    .attr(&#x27;stroke&#x27;, entry.color)
                    .attr(&#x27;stroke-width&#x27;, entry.lines.lineWidth)
                    .attr(&#x27;d&#x27;, line);

                this.graphBody.selectAll(&#x27;.dot&#x27;)
                    .data(entry.data.filter((d) &#x3D;&gt; !isNaN(d[1])))
                    .enter().append(&#x27;circle&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;dot&#x27;)
                    .attr(&#x27;stroke&#x27;, entry.color)
                    .attr(&#x27;fill&#x27;, entry.color)
                    .attr(&#x27;cx&#x27;, line.x())
                    .attr(&#x27;cy&#x27;, line.y())
                    .attr(&#x27;r&#x27;, entry.lines.pointRadius);
            }
        }
    }

    /**
     * Function that shows labeling via mousmove.
     */
    private mousemoveHandler &#x3D; () &#x3D;&gt; {
        const coords &#x3D; d3.mouse(this.background.node());
        this.ypos &#x3D; [];
        this.idxOfPos &#x3D; 0;
        this.labelTimestamp &#x3D; [];
        this.preparedData.forEach((entry, entryIdx) &#x3D;&gt; {
            const idx &#x3D; this.getItemForX(coords[0] + this.bufferSum, entry.data);
            this.showDiagramIndicator(entry, idx, coords[0], entryIdx);
        });
        // focus do not overlap each other
        if (this.ypos !&#x3D;&#x3D; undefined) {
            let firstLabel &#x3D; [];
            // only push one of the pairs of objects (rectangle and label)
            this.ypos.forEach((e, i) &#x3D;&gt; {
                if (i % 2 &#x3D;&#x3D;&#x3D; 0) {
                    firstLabel.push(e);
                }
            });
            let yPos &#x3D; firstLabel.sort((a, b) &#x3D;&gt; a.y - b.y);
            yPos.forEach((p, i) &#x3D;&gt; {
                if (i &gt; 0) {
                    let last &#x3D; yPos[i - 1].y;
                    yPos[i].off &#x3D; Math.max(0, (last + 30) - yPos[i].y);
                    yPos[i].y +&#x3D; yPos[i].off;
                }
            });
            yPos.sort((a, b) &#x3D;&gt; a.idx - b.idx);

            let c1 &#x3D; 0;
            let c2 &#x3D; 0;

            // d3.selectAll(&#x27;.mouse-focus-label&#x27;)
            d3.selectAll(&#x27;.focus-visibility&#x27;)
                .attr(&#x27;transform&#x27;, (d, i) &#x3D;&gt; {
                    // pairs of 2 objects (rectangle (equal) and label (odd))
                    if (i &gt; 0) {
                        c1 &#x3D; (i - 1) % 2;
                    }
                    c2 +&#x3D; c1;
                    if (yPos[c2] &amp;&amp; yPos[c2].off) {
                        return &#x27;translate(0,&#x27; + (5 + yPos[c2].off) + &#x27;)&#x27;;
                    }
                });
        }
    }

    /**
     * Function that hides the labeling inside the graph.
     */
    private mouseoutHandler &#x3D; () &#x3D;&gt; {
        this.hideDiagramIndicator();
    }

    /**
     * Function starting the drag handling for the diagram.
     */
    private panStartHandler &#x3D; () &#x3D;&gt; {
        this.draggingMove &#x3D; false;
        this.dragMoveStart &#x3D; d3.event.x;
        this.dragMoveRange &#x3D; [this.xAxisRange.from, this.xAxisRange.to];
    }

    /**
     * Function that controlls the panning (dragging) of the graph.
     */
    private panMoveHandler &#x3D; () &#x3D;&gt; {
        this.draggingMove &#x3D; true;
        if (this.dragMoveStart &amp;&amp; this.draggingMove) {
            let diff &#x3D; -(d3.event.x - d3.event.subject.x);
            let amountTimestamp &#x3D; this.dragMoveRange[1] - this.dragMoveRange[0];
            let ratioTimestampDiagCoord &#x3D; amountTimestamp / this.width;
            let newTimeMin &#x3D; this.dragMoveRange[0] + (ratioTimestampDiagCoord * diff);
            let newTimeMax &#x3D; this.dragMoveRange[1] + (ratioTimestampDiagCoord * diff);

            this.xAxisRangePan &#x3D; [newTimeMin, newTimeMax];
            this.timespan &#x3D; { from: this.xAxisRangePan[0], to: this.xAxisRangePan[1] };
            this.plotGraph();
        }
    }

    /**
     * Function that ends the dragging control.
     */
    private panEndHandler &#x3D; () &#x3D;&gt; {
        this.changeTime(this.xAxisRangePan[0], this.xAxisRangePan[1]);
        this.plotGraph();
        this.dragMoveStart &#x3D; null;
        this.draggingMove &#x3D; false;
    }

    /**
     * Function that starts the zoom handling.
     */
    private zoomStartHandler &#x3D; () &#x3D;&gt; {
        this.dragging &#x3D; false;
        this.dragStart &#x3D; d3.mouse(this.background.node());
        this.xAxisRangeOrigin.push([this.xAxisRange.from, this.xAxisRange.to]);
    }

    /**
     * Function that draws a rectangle when zoom is started and the mouse is moving.
     */
    private zoomHandler &#x3D; () &#x3D;&gt; {
        this.dragging &#x3D; true;
        this.drawDragRectangle();
    }

    /**
     * Function that ends the zoom handling and calculates the via zoom selected time interval.
     */
    private zoomEndHandler &#x3D; () &#x3D;&gt; {
        if (!this.dragStart || !this.dragging) {
            if (this.xAxisRangeOrigin[0]) {
                // back to origin range (from - to)
                this.changeTime(this.xAxisRangeOrigin[0][0], this.xAxisRangeOrigin[0][1]);
                this.xAxisRangeOrigin &#x3D; [];
                this.plotGraph();
            }
        } else {
            let xDomainRange;
            if (this.dragStart[0] &lt;&#x3D; this.dragCurrent[0]) {
                xDomainRange &#x3D; this.getxDomain(this.dragStart[0], this.dragCurrent[0]);
            } else {
                xDomainRange &#x3D; this.getxDomain(this.dragCurrent[0], this.dragStart[0]);
            }
            this.xAxisRange &#x3D; { from: xDomainRange[0], to: xDomainRange[1] };
            this.changeTime(this.xAxisRange.from, this.xAxisRange.to);
            this.plotGraph();
        }
        this.dragStart &#x3D; null;
        this.dragging &#x3D; false;
        this.resetDrag();
    }

    /**
     * Function that returns the timestamp of provided x diagram coordinates.
     * @param start {Number} Number with the minimum diagram coordinate.
     * @param end {Number} Number with the maximum diagram coordinate.
     */
    private getxDomain(start: number, end: number) {
        let domMinArr &#x3D; [];
        let domMaxArr &#x3D; [];
        let domMin;
        let domMax;
        let tmp;
        let lowestMin &#x3D; Number.POSITIVE_INFINITY;
        let lowestMax &#x3D; Number.POSITIVE_INFINITY;

        start +&#x3D; this.bufferSum;
        end +&#x3D; this.bufferSum;

        this.preparedData.forEach((entry) &#x3D;&gt; {
            domMinArr.push(entry.data.find((elem, index, array) &#x3D;&gt; {
                if (elem.xDiagCoord) {
                    if (elem.xDiagCoord &gt;&#x3D; start) {
                        return array[index];
                    }
                }
            }));
            domMaxArr.push(entry.data.find((elem, index, array) &#x3D;&gt; {
                if (elem.xDiagCoord &gt;&#x3D; end) {
                    return array[index];
                }
            }));
        });

        for (let i &#x3D; 0; i &lt;&#x3D; domMinArr.length - 1; i++) {
            if (domMinArr[i] !&#x3D; null) {
                tmp &#x3D; domMinArr[i].xDiagCoord;
                if (tmp &lt; lowestMin) {
                    lowestMin &#x3D; tmp;
                    domMin &#x3D; domMinArr[i].timestamp;
                }
            }
        }
        for (let j &#x3D; 0; j &lt;&#x3D; domMaxArr.length - 1; j++) {
            if (domMaxArr[j] !&#x3D; null) {
                tmp &#x3D; domMaxArr[j].xDiagCoord;
                if (tmp &lt; lowestMax) {
                    lowestMax &#x3D; tmp;
                    domMax &#x3D; domMaxArr[j].timestamp;
                }
            }
        }
        return [domMin, domMax];
    }

    /**
     * Function that configurates and draws the rectangle.
     */
    private drawDragRectangle() {
        if (!this.dragStart) { return; }
        this.dragCurrent &#x3D; d3.mouse(this.background.node());

        const x1 &#x3D; Math.min(this.dragStart[0], this.dragCurrent[0]);
        const x2 &#x3D; Math.max(this.dragStart[0], this.dragCurrent[0]);

        if (!this.dragRect &amp;&amp; !this.dragRectG) {

            this.dragRectG &#x3D; this.graph.append(&#x27;g&#x27;)
                .style(&#x27;fill-opacity&#x27;, .2)
                .style(&#x27;fill&#x27;, &#x27;blue&#x27;);

            this.dragRect &#x3D; this.dragRectG.append(&#x27;rect&#x27;)
                .attr(&#x27;width&#x27;, x2 - x1)
                .attr(&#x27;height&#x27;, this.height)
                .attr(&#x27;x&#x27;, x1 + this.bufferSum)
                .attr(&#x27;class&#x27;, &#x27;mouse-drag&#x27;)
                .style(&#x27;pointer-events&#x27;, &#x27;none&#x27;);
        } else {
            this.dragRect.attr(&#x27;width&#x27;, x2 - x1)
                .attr(&#x27;x&#x27;, x1 + this.bufferSum);
        }
    }

    /**
     * Function that disables the drawing rectangle control.
     */
    private resetDrag() {
        if (this.dragRectG) {
            this.dragRectG.remove();
            this.dragRectG &#x3D; null;
            this.dragRect &#x3D; null;
        }
    }

    /**
     * Function that returns the metadata of a specific entry in the dataset.
     * @param x {Number} Number of the dataset entry.
     * @param data {DataEntry} Array with the data of each dataset entry.
     */
    private getItemForX(x: number, data: DataEntry[]): number {
        const index &#x3D; this.xScaleBase.invert(x);
        const bisectDate &#x3D; d3.bisector((d: DataEntry) &#x3D;&gt; {
            return d[0];
        }).left;
        return bisectDate(data, index);
    }

    /**
     * Function that disables the labeling.
     */
    private hideDiagramIndicator() {
        this.focusG.style(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
        d3.selectAll(&#x27;.focus-visibility&#x27;)
            .attr(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
    }

    /**
     * Function that enables the lableing of each dataset entry.
     * @param entry {DataEntry} Object containing the dataset.
     * @param idx {Number} Number with the position of the dataset entry in the data array.
     * @param xCoordMouse {Number} Number of the x coordinate of the mouse.
     * @param entryIdx {Number} Number of the index of the entry.
     */
    private showDiagramIndicator &#x3D; (entry, idx: number, xCoordMouse: number, entryIdx: number) &#x3D;&gt; {
        const item: DataEntry &#x3D; entry.data[idx];
        if (item !&#x3D;&#x3D; undefined &amp;&amp; item.yDiagCoord) {
            // create line where mouse is
            this.focusG.style(&#x27;visibility&#x27;, &#x27;visible&#x27;);
            // show label if data available for time
            this.chVisLabel(entry, true);

            let onLeftSide &#x3D; false;
            if ((this.background.node().getBBox().width + this.bufferSum) / 2 &gt; item.xDiagCoord) { onLeftSide &#x3D; true; }

            let labelBuffer &#x3D; ((this.timespan.from / (this.timespan.to - this.timespan.from)) * 0.0001)
                * ((this.timespan.from / (this.timespan.to - this.timespan.from)) * 0.0001);

            labelBuffer &#x3D; Math.max(4, labelBuffer);

            this.showLabelValues(entry, item, onLeftSide);
            this.showTimeIndicatorLabel(item, onLeftSide, entryIdx);

            if ((xCoordMouse) &gt; (item.xDiagCoord + labelBuffer) || (xCoordMouse) &lt; (item.xDiagCoord - labelBuffer)) {
                // hide label if mouse to far from coordinate
                this.chVisLabel(entry, false);

                if (entry.data[idx - 1] &amp;&amp; entry.data[idx - 1].xDiagCoord + labelBuffer &gt;&#x3D; xCoordMouse) {
                    this.showLabelValues(entry, entry.data[idx - 1], onLeftSide);
                    this.showTimeIndicatorLabel(item, onLeftSide, entryIdx);

                    this.chVisLabel(entry, true);
                }
            }
        } else {
            // hide label if no data available for time
            this.chVisLabel(entry, false);
        }
    }

    /**
     * Function to change visibility of label and white rectangle inside graph (next to mouse-cursor line).
     * @param entry {DataEntry} Object containing the dataset.
     * @param visible {Boolean} Boolean giving information about visibility of a label.
     */
    private chVisLabel(entry, visible: boolean) {
        if (visible) {
            entry.focusLabel
                .attr(&#x27;visibility&#x27;, &#x27;visible&#x27;)
                .attr(&#x27;class&#x27;, &#x27;focus-visibility&#x27;);
            entry.focusLabelRect
                .attr(&#x27;visibility&#x27;, &#x27;visible&#x27;)
                .attr(&#x27;class&#x27;, &#x27;focus-visibility&#x27;);
        } else {
            entry.focusLabel
                .attr(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
            entry.focusLabelRect
                .attr(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
        }
    }

    /**
     * Function to show the labeling inside the graph.
     * @param entry {DataEntry} Object containg the dataset.
     * @param item {DataEntry} Object of the entry in the dataset.
     * @param onLeftSide {Boolean} Boolean giving information if the mouse is on left side of the diagram.
     */
    private showLabelValues(entry, item: DataEntry, onLeftSide: boolean) {
        let id &#x3D; 1;
        if (entry.focusLabel) {
            entry.focusLabel.text(item[id] + (entry.axisOptions.uom ? entry.axisOptions.uom : &#x27;&#x27;));
            const entryX &#x3D; onLeftSide ?
                item.xDiagCoord + 4 : item.xDiagCoord - this.getDimensions(entry.focusLabel.node()).w + 4;
            entry.focusLabel
                .attr(&#x27;x&#x27;, entryX)
                .attr(&#x27;y&#x27;, item.yDiagCoord);
            entry.focusLabelRect
                .attr(&#x27;x&#x27;, entryX)
                .attr(&#x27;y&#x27;, item.yDiagCoord - this.getDimensions(entry.focusLabel.node()).h + 3)
                .attr(&#x27;width&#x27;, this.getDimensions(entry.focusLabel.node()).w)
                .attr(&#x27;height&#x27;, this.getDimensions(entry.focusLabel.node()).h);
            this.ypos.push({ idx: this.idxOfPos++, y: item.yDiagCoord, off: 0 });
        }
    }

    /**
     * Function to show the time labeling inside the graph.
     * @param item {DataEntry} Object of the entry in the dataset.
     * @param onLeftSide {Boolean} Boolean giving information if the mouse is on left side of the diagram.
     * @param entryIdx {Number} Number of the index of the entry.
     */
    private showTimeIndicatorLabel(item: DataEntry, onLeftSide: boolean, entryIdx: number) {
        // timestamp is the time where the mouse-cursor is
        this.labelTimestamp[entryIdx] &#x3D; item.timestamp;
        let min &#x3D; d3.min(this.labelTimestamp);
        let idxOfMin &#x3D; this.labelTimestamp.findIndex((elem) &#x3D;&gt; elem &#x3D;&#x3D;&#x3D; min);
        let right &#x3D; item.xDiagCoord + 2;
        let left &#x3D; item.xDiagCoord - this.getDimensions(this.focuslabelTime.node()).w - 2;
        this.focuslabelTime.text(moment(this.labelTimestamp[idxOfMin]).format(&#x27;DD.MM.YY HH:mm&#x27;));
        this.focuslabelTime
            .attr(&#x27;x&#x27;, onLeftSide ? right : left)
            .attr(&#x27;y&#x27;, 13);
        if (item.timestamp &#x3D;&#x3D;&#x3D; min) {
            this.highlightFocus
                .attr(&#x27;x1&#x27;, item.xDiagCoord)
                .attr(&#x27;y1&#x27;, 0)
                .attr(&#x27;x2&#x27;, item.xDiagCoord)
                .attr(&#x27;y2&#x27;, this.height)
                .classed(&#x27;hidden&#x27;, false);
        }
    }

    /**
     * Function that returns the boundings of a html element.
     * @param el {Object} Object of the html element.
     */
    private getDimensions(el: any): { w: number, h: number } {
        let w &#x3D; 0;
        let h &#x3D; 0;
        if (el) {
            const dimensions &#x3D; el.getBBox();
            w &#x3D; dimensions.width;
            h &#x3D; dimensions.height;
        } else {
            console.log(&#x27;error: getDimensions() &#x27; + el + &#x27; not found.&#x27;);
        }
        return {
            w,
            h
        };
    }

    /**
     * Function to generate uuid for a diagram
     */
    private uuidv4(): string {
        return this.s4() + this.s4() + &#x27;-&#x27; + this.s4() + &#x27;-&#x27; + this.s4() + &#x27;-&#x27; + this.s4() + &#x27;-&#x27; + this.s4() + this.s4() + this.s4();
    }

    /**
     * Function to generate components of the uuid for a diagram
     */
    private s4(): string {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }

    /**
     * Function that logs the error in the console.
     * @param error {Object} Object with the error.
     */
    private onError(error: any) {
        console.error(error);
    }

}
</code></pre>
    </div>
</div>






                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'YAxisSelection.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <script src="../js/menu-wc.js"></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
